### 前置知识

#### RTT

> RTT(Round-Trip Time)，往返时延。在计算机网络中它是一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。
>
> 往返延时(RTT)由三个部分决定：即链路的传播时间、末端系统的处理时间以及路由器的缓存中的排队和处理时间。其中，前面两个部分的值作为一个TCP连接相对固定，路由器的缓存中的排队和处理时间会随着整个网络拥塞程度的变化而变化。所以RTT的变化在一定程度上反映了网络拥塞程度的变化。



### 可靠数据传输协议(reliable data transfer protocol)  => rdt



#### 实现一个可靠数据传输协议的原因

因为链路层和网络层在传输数据的时候，都可能会发生packet的丢失，或者比特的错位，所以为了可靠的传输我们的数据，你必须要设计一个可靠的传输协议。



#### 演化

第一阶段，我们先假设我们的数据是肯定能到达的。首先我们可以提供的功能：

1. 差错检查：这个很方便理解，就和UDP协议里面的东西差不多，我们传输的数据不仅仅是丢失了，也有可能仅仅是几个bit的变化，这样也是不行的，所以我们需要差错检查来检查我们传输的数据是否发生了变化。
2. 接收方反馈：我们仅仅发出去是不够的，如果发出去就不管了，那我们不就和UDP一样了吗？我们需要引入一个反馈，就是接收方收到我们的数据之后，它能够告诉我们，你的数据我接收到了。这个就叫做**肯定确认**(positive acknowledgment)。而如果差错检查检查出了问题，那我们就来一个**否定确认(negative acknowledgment)**。
3. 重传：当我们接收到了接收方的否定确认的时候，我们就可以对这种情况采取措施，那就是重传，重新发送报文。就是条舔狗。当然，也有可能对方都没有收到报文，也就无从谈起接收方反馈了，所以我们会设置一个定时器的，这个是下一个阶段的内容。

第一个阶段中，我们已经大致能看出一个可靠协议的轮廓了，但是其中还是有很多问题的。首先就是我们上面的内容其实是建立在一些前提上面的，比如我们的数据肯定是能够发送到接收方的，不然我们重传那一步里面就无从谈起收到否定确认了，还有就是我们发送的包都是能够按顺序到达接收方那里，但是实际的情况中，这种情况不一定的。比如我发送了两个包，A包和B包，但是B包先到了，接收方经过检查OK了，于是发送了ACK，但是后到的A包不OK，于是发送了NCK，但是我发送方并不知道具体哪个包出了问题。他可能就直接重传了B包。所以我们后面会引入序号的概念，而计算机网络里面这个阶段采取的方法很简单，就一个一个发，不受到第一个包的ACK我就不发第二个。这个就叫做**停等协议**。

当然，书里面这个时候也提出了一个问题，即：如果接收方反馈的时候发生了传输问题，应该怎么办呢？发送方发现反馈出了问题，那我就直接重传就好了，可是接收方如何判断这个是重发的而不是新的呢。于是这里引入了**序号(sequence number)**的概念和字段，再停等协议里面其实很简单，这个只要是1或者０就可以了，因为停等协议是发完一个收到正确的反馈之后才会发下一个的，即切换这个序号的字段。如果发送方重发了，接收方就能通过最近一次的序号知道这个是重发的报文

第二个阶段，之前我们有个很重要的假设，就是我们发送的数据不会发生丢包的情况，如果发生了丢包，想象一下，那我们在停等协议中，是不是要一直等待接收方的反馈？所以理所当然的，我们会引入一个计时器，如果我们等的够久了，我们就直接重传了。重传真的是个万灵药啊。当然，也有可能是真的网络太慢，如果你重传了，而之前那个包没有丢，接收方就可能收到２个包，幸好我们已经有序号的概念了。

至此，我们其实已经能够得到了一个不完美的可靠传输协议了。但是，他仍然有自己的问题。

首先就是性能问题，之前我们很多时候都依靠的是停等协议，就是我们发完一个包之后会等待的，直到等到接收方的反馈之后再发第二个包。虽然这能肯定让我们顺序的发送我们的数据，但是这个会造成严重的性能问题的。无论是进入链路的时间，还是往返rtt的时间，甚至是在路由器里面排队的时间，都会造成大量的时间浪费。

于是在第三个阶段我们正式引入了流水线协议的概念，即我们并不等待数据确认ack之后再发送下一个报文，而是直接发送报文，不等待接收方的ack确认，这样就可以避免等待的时间，就像流水线一样，报文不停的发送。

可是这样的话，原来的措施就不够了，比如序号。只有0和1的话，那不停的返回0和1的ack你怎么能确认是哪个报文呢？所以我们必须引入下面的步骤：

1. 增加序号的范围
2. 

