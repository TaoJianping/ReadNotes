## 面向连接的运输：TCP

前面介绍了那么多的可靠协议需要的东西，就是为了引出最重要的TCP协议。

 TODO:p153

> 最大报文段长度( Maximum Segment Size, MSS )
>
> 最大传输单元( Maximum Transmission Unit, MTU )



#### 特点

- 面向连接的(connection-oriented)：面向连接的意思是，在用TCP协议传输数据前，必须有一个握手的阶段，即他们会发送一些预备报文段，来建立确保数据传输的参数。作为连接的双方，都会初始化很多TCP的状态变量。注意，这个是一种抽象的概念，实际上，底层的链路等硬件根本不会看到这些‘连接’，他们看到的只是数据报。
- 双全工服务(full-duplex service)：建立连接的双方可以互相传输数据，并且是点对点的，并不会一对多的放松。

![image](https://ws3.sinaimg.cn/large/005wgNfbgy1g01vz07ln8j30gb079mxi.jpg)

上图是一个最简单的TCP示意图，**send buffer**和**receive buffer**就是在握手阶段建立的状态。



#### TCP报文段结构

![image](https://wx3.sinaimg.cn/large/005wgNfbgy1g01w57u82uj30d00bx3yy.jpg)

- 源端口号(18bit)
- 目标端口号(18bit)
- 序号字段( Sequence number field, 32bit )
- 确认号字段( Acknowledgment number, 32bit )
- 接收窗口字段( receive window field, 16bit )
- 首部长度字段( header length field, 4bit )
- 可选与变长的选项字段( options field, 32bit)
- 标志字段( flag field, 6bit )



##### 序号和确认号的特点：

- 他的数字不是报文段的序号，而是基于字节流的，比如发送一个1000字节的报文，seq=0,ack=1000
- 累计确认：如果接收方收到0-535的报文段和900-1000的报文段，中间536-899的报文段丢失，那么他之后的ack永远会设置成536，因此TCP只确认该流中至第一个丢失字节为止的字节
- 针对上面第二个中提到的900-1000的报文段，实际上TCP RFC并没有强行规定你应该如何处理，你要丢掉或者缓存都可以，当然一般都是缓存下来了。
- 初始序号一般都是随机设置的



#### 往返时间的估计和超时

因为TCP协议是用超时/重传协议来处理数据报文丢失的问题的。所以这个超时时间的设定就是重中之重。那我们应该如何设置这个超时时间呢？或者说我们应该通过哪些数据来组成这个超时时间呢？

首先要明确，我们这个超时时间要尽量大于RTT的时间，因为如果小于的话会造成频i繁的重传，但是也不能超过太多，也就是过分大于RTT的时间，这样的话会造成不必要的等待时间的浪费。 

所以确定这个RTT的大概时间是非常重要的。怎么求呢？

1. 大部分TCP的实现不会记录每份报文的RTT的时间，而只会记录某一刻一个报文的RTT时间，规范的说，就是仅为一个发送且尚未被确认的报文段记录一个RTT时间，记作SampleRTT

2. $$
   EstimatedRTT = ( 1 - α ) * EstimatedRTT + α * SampleRTT
   $$

   这个公式就是TCP维持的一个估计的RTT时间，其中SampleRTT的时间就是第一步中记录的数字，而α是个值，你可以自己在实现TCP的时候设置，但是根据[ RFC 6298 ]中的提议，通常α的值会被设置成0.125。

3. 除了SampleRTT和EstimatedRTT这两个数据，还需要求一个数据，就是每次SampleRTT记录的值的变化情况，我记得统计学里面是叫做偏差？早知道真的好好学了。[ RFC 6298 ] 定义了RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度
   $$
   DevRTT = ( 1- β ) * DevRTT + β * | SampleRTT - EstimatedRTT |
   $$
   注意到DevRTT是一个SampleRTT和EstimatedRTT之间差值的EWMA( Exponential Weighted Moving Average, EWMA )。代表的含义就是，如果SampleRTT的波动小，则DevRTT的值就小，反之就会很大。另外β的推荐值为0.25。

4. 好的，我们现在已经能够得到两个关键的数据，一个是EstimatedRTT，另一个是DevRTT。那我们如何设置超时间隔呢？很简单，首先，我们要尽量大于EstimatedRTT，不然会造成频繁的重传，毕竟EstimatedRTT某种程度上代表这EstimatedRTT的平均值，另外，也不能过大，这样会造成不必要的浪费。看，就像我们一开始提到的那样，好的，我们正好有DevRTT可以用，来避免这种状况。在上面这些想法之后，我们列出公式：
   $$
   TimeoutInterval = EstimatedRTT + 4 * DevRTT
   $$
   初始值我们推荐设置为1，随后超时直接加倍，只要收到报文段并更新EstimatedRTT，就使用上述公式再次计算TimeoutInterval。



#### 可靠传输协议

我们知道TCP是在不可靠的IP协议上，提供可靠的传输协议。具体是指：TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流。

那他是通过哪些来实现这个功能的呢？我们上篇提到的手段就可以用到这里了。

1. 定时器
2. 检验和
3. 序号
4. 肯定确认
5. GBN协议和选择重传协议的结合

有几个要注意的地方：

1. 定时器的开销很大，所以推荐的方法是仅使用单一的重传定时器，即使有多个已发送但还未被确认的报文段。
2. 超时触发重传存在着一个问题，就是可能周期会很长，所以引入了冗余ACK( duplicate ACK )，如果传输过来一些包，发现中间少了一个报文段，可能是传输过程中丢失了，然后因为TCP是没有否定确认的，所以TCP直接重复发送三次最后一个按序到达的报文段的序号，表明要重新发送丢失的报文段。
3. TCP是把GBN协议和选择重传协议结合起来一起使用了，首先，他是采用累计确认的方式，就是说他只会确认最后一个按序到达报文段。而失序却提前到达的报文段他是不会发送ACK的。但是他会把这些缓存起来的。GBN协议如果发现有失序的报文段，会直接重传之后所有的报文段，但是TCP不会。并且他还引入了一个**选择确认( selective acknowledgment )**的概念，就是TCP报文会有专门的地方显示接收情况，则接收方可以很明显的看出到底是那个报文段丢失了。



#### 拥塞控制

TCP的流量控制主要是因为接收端维护了一个缓冲区来缓存那些接收了但是还没有交付给上层的应用，当缓冲区满了之后传过来的报文会被丢弃掉，造成了浪费，所以为了避免这种状况维持了一个字段，rwnd。

上面这种情况是在接收端缓冲区满了的情况造成的传输浪费，但是还有一种情况是整个网络的拥塞了，这个时候如果大范围的传输报文的话，同样造成了网络资源的浪费。所以在整个网络都处于拥塞状态的情况下，发送方应该控制自己发送的频率，在IP层不提供网络拥塞服务的情况下，只能由TCP层自己来判断。我们可以设置一个参数，cwnd( congestion window )，即拥塞窗口，在发送端，未被确认的报文不会超过cwnd和rwnd的最小值。
$$
LastBytesSent - LastBytesAcked \leq \min \{rwnd, cwnd\}
$$
现在我们把我们要研究的问题归纳为3个

1. 一个TCP发送方应该如何限制它向其连接发送流量的速率呢？
2. 一个TCP发送方应该如何感知从它到目的地之间的路径上存在着拥塞呢？
3. 当发送方感知到端到端的拥塞时，采用何种算法来改变发送速率呢？

第一个问题，我们可以假设一些极端情况，比如rwnd无限大，即接收端的缓存无限大。这样的话，根据上面的那个公式，我们可以简单的简化为cwnd控制着这个窗口，所以只要改变了cwnd，那么发送方就可以限制它向其连接发送流量的速率。

第二个问题。因为IP层没有提供这个感知拥塞的服务，所以TCP只能用自己的一些事件来检查拥塞。如果简化为丢包了就代表这网络拥塞的话，那么在TCP中，有两种情况代表着丢包，一个是超时重传，另一个是冗余ACK。当发生这两个事件之后，那么就代表着网络发生了拥塞。

前两个问题答完了，可以简单的归纳一下

> 发送方通过出发两个事件超时重传和冗余ACK来确定网络处于拥塞状态，再通过调节cwnd来控制发送速率

