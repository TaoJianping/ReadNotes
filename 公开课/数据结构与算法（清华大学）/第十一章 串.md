# 串

## 11.1 串及串匹配

### 前缀（prefix）和后缀（suffix） 

```c++
prefix(S, k) = S.substr(0, k) = S[0, k);
suffix(S, k) = S.substr(n - k, k) = S[n - k, n]
```

> **平凡子串（trivial substring）、平凡前缀（trivial prefix）和平凡后缀（trivial suffix）**
>
> - 空串是任何字符串的子串，也是任何字符串的前缀和后缀；
>
> - 任何字符串都是自己的子串，也是自己的前缀和后缀。

> 字符串本身之外的所有非空子串、前缀和后缀，分别叫做**真子串（proper substring）**、**真前缀（proper prefix）**和**真后缀（proper suffix）**。



## 11.3 KMP算法

相比于蛮力算法对文本串长度一个一个字节的比较，KMP算法的本质就是要看能不能跳过一些字节来匹配。而能做到这一点的原因是

- 模式串是我们已知的；
- 匹配到的模式串和文本串在匹配失败的那一刻也是已知的，并且是相等的；

问题的关键就是：如何得到我们要跳过的字节？



## 11.4 BM算法

### 11.4.1 思路与框架

BM算法中，模式串P与文本串T的对准位置依然“自左向右”推移，而在每一对准位置却是“自右向左”地逐一比对各个字符。具体地，在每一轮自右向左的对比过程中，一旦发现失配，则将P向右移一定距离并再次与T对准，然后重新一轮自右向左的扫描对比。为实现高效率，BM算法同样需要充分利用以往的对比所提供的信息，使得P可以“安全地”向后移动尽可能远的距离。

```c++
// Todo 主体框架
```



### 11.4.2 坏字符策略

#### 坏字符

坏字符指的是在失配时文本串被比较的那个字符。



#### bc[]表

坏字符在Pattern串里面出现的最右位置。



#### bc[]表构造算法

```c++
// Todo
```



### 11.4.3 好后缀策略

#### 构思

针对已经成功匹配的模式串的后缀，这个也是经验，能够利用的。我们用这个成功比配的模式串后缀进行平移，针对坏字符出现在好后缀中从而导致只能向右平移一格的情况。



#### 好后缀

每轮对比中的若干次成功匹配，都对应于模式串P的一个后缀，称为“好后缀”（good suffix）。



### 11.4.4 gs[]表构造算法

#### MS串与ss[]表

对于任一整数$j \in [0, m)$，在P[0, j]的所有后缀中，考察那些与P的某一后缀匹配者。若将其中的最长者记做MS[j]，则ss[j]就是该串的长度|MS[j]|。特别的，当MS[j]不存在时，取ss[j]=0;。









