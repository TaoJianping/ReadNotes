# 第二十讲：死锁和进程通信

## 提纲

- 死锁概念
- 死锁处理方法
- 银行家算法
- 死锁检测
- 进程通信概念
- 信号和管道
- 消息队列和共享内存



## 20.1 死锁概念

死锁是进程之间由于共享资源所导致的一种无限期等待的情况。



### 概念

由于竞争资源或者通信关系，两个或者更多线程执行中出现，永远相互等待只能由其他进程引发的事件。

![f002b67e-8d5a-491f-9fc2-54ac43a98140.png](https://storage.live.com/items/D2F4C87291B41CFE!1596871?authkey=AONVyty4CuEfbG8)



### 进程访问资源的流程

- 资源类型有很多个R1、R2......、Rm

- 每类资源$R_i$有$W_i$个实例

- 进程访问资源的流程

    - 请求/获取

        申请空闲资源

    - 使用/占用

        进程占用资源

    - 释放

        资源状态由占用变成空闲



### 资源分类

#### 可重用资源（Reusable Resource）

- 资源不能被删除且任何时刻只能有一个进程使用
- 进程释放资源后，其他进程可重用

- 可重用资源实例
    - 硬件：处理器、I/O通道、主和副存储器、设备等
    - 软件：文件、数据库和信号量等数据结构
- 可能出现死锁
    - 每个进程占用一部分资源并请求其他资源

#### 消耗资源（Consumable Resource）

- 资源的创建和销毁
- 消耗资源示例
    - 在I/O缓冲区的中断、信号、消息等
- 可能出现死锁
    - 进程之间相互等待接收对方的信息



### 资源分配图

描述资源和进程间的分配和占用关系的有向图。

![1d721ac2-2dcc-44fa-be6e-de469e2b318d.png](https://storage.live.com/items/D2F4C87291B41CFE!1596872?authkey=AONVyty4CuEfbG8)

> 不能简单依靠是否出现循环来判断是否出现死锁。



### 出现死锁的必要条件

- 互斥
    - 任何时刻只能有一个进程使用一个资源实例
- 持有并等待
    - 进程保持至少一个资源，并正在等待获取其他进程持有的资源
- 非抢占
    - 资源只能在进程使用后自愿释放
- 循环等待



## 20.2 死锁处理方法

### 死锁处理方法

- 死锁预防（Deadlock Prevention）
    - 确保系统永远不会进入死锁状态
- 死锁避免（Deadlock Avoidance）
    - 在使用前进行判断，只允许不会出现死锁的进程请求资源
- 死锁检测和恢复（Deadlock Detection & Recovery）
    - 在检测到运行系统进入死锁状态后，进行恢复
- 由应用进程处理死锁
    - 通常操作系统忽略死锁



### 死锁预防：限制申请方式

预防是采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件。

- 互斥
    - 把互斥的共享资源封装成可同时访问
- 持有并等待
    - 进程请求资源时，要求它不持有任何其他资源
    - 仅允许进程在开始执行时，一次请求所有需要的资源
    - 资源利用率低
- 非抢占
    - 如进程请求不能立即分配的资源，则释放已经占有的资源
    - 只有能够同时获得所有需要资源时，才执行分配操作

- 循环等待
    - 对资源排序，要求进程按顺序请求资源



### 死锁避免

利用额外的先验信息，在分配资源时判断是否会出现死锁，只有在不会死锁时分配资源

- 要求进程声明需要资源的**最大数目**
- 限定**提供**与**分配**的资源数量，确保满足进程的最大需求
- 动态检查资源分配状态，确保不会出现环形等待



### 系统资源分配的安全状态

- 当进程请求资源时，系统判断分配后是否处于安全状态

- 系统处于安全状态
    - 针对所有已经占用的进程，存在安全序列
- 序列$<P_1, P_2, ..., P_N>$是安全的
    - $P_i$要求的资源$\leq$当前可用的资源+所有$P_j$持有资源，其中$j < i$
    - 如果$P_i$的资源请求不能立即分配，则$P_i$等待所有$P_j(j<i)$完成
    - $P_i$完成后，$P_{i+1}$可得到所需资源，执行并释放所分配的资源
    - 最终整个序列的所有$P_i$都能获得所需资源

![c8f6ade4-3774-4794-ba6f-fec1144aa8fd.png](https://storage.live.com/items/D2F4C87291B41CFE!1596873?authkey=AONVyty4CuEfbG8)



## 银行家算法（Banker's Algorithm）

银行家算法是一个避免死锁产生的算法。以银行借贷分配策略为基础，判断并保证系统处于安全状态。

- 客户在第一次申请贷款时，声明所需的最大资金量，在满足所有贷款要求并完成项目时，及时归还。
- 在客户贷款数量不超过银行拥有的最大值时，银行家家尽量满足客户需求。
- 类比
    - 银行家：操作系统
    - 资金：资源
    - 客户：申请资源的线程

![fdb771d5-e023-4265-b97e-8bf2bca12f01.png](https://storage.live.com/items/D2F4C87291B41CFE!1596881?authkey=AONVyty4CuEfbG8)

![64a491da-f49f-46d8-8c46-48c3af87ff3a.png](https://storage.live.com/items/D2F4C87291B41CFE!1596882?authkey=AONVyty4CuEfbG8)

![81ba7d2b-22ba-4c85-8a4e-fd4e717ef29c.png](https://storage.live.com/items/D2F4C87291B41CFE!1596883?authkey=AONVyty4CuEfbG8)



## 死锁检测

- 允许系统进入死锁状态
- 维护系统的资源分配图
- 定期调用死锁检测算法来搜索图中是否存在死锁
- 出现死锁时，用死锁恢复机制进行恢复



### 死锁检测算法

#### 数据结构

![612c9f41-bc2c-4084-b1d2-edd4627526e3.png](https://storage.live.com/items/D2F4C87291B41CFE!1596885?authkey=AONVyty4CuEfbG8)

#### 算法

![f260ed48-0770-49b7-9872-f9a481e53345.png](https://storage.live.com/items/D2F4C87291B41CFE!1596887?authkey=AONVyty4CuEfbG8)

#### 使用

死锁检测的时间和周期的选择依据

- 死锁多久可能会发生
- 多少进程需要被回滚

资源图可能有多少个循环

- 难于分辨“造成”死锁的关键进程

#### 死锁恢复

##### 进程终止

- 终止所有的死锁进程
- 一次只终止一个进程知道死锁消除
- 终止进程的顺序应该是
    - 进程的优先级
    - 进程已运行时间以及还需运行的时间
    - 进程已占用资源
    - 进程完成需要的资源
    - 终止进程数目
    - 进程是交互还是批处理

##### 资源抢占

- 选择被抢占进程
    - 最小成本目标
- 进程回退
    - 返回到一些安全状态，重启进程到安全状态
- 可能出现饥饿
    - 同一进程可能一直被选作被抢占着



## 进程通信（IPC, Inter-Process Communication）

- 进程通信时进程进行通信和同步的机制
- IPC提供两个基本操作
    - 发送操作：send(message)
    - 接收操作：receive(message)

- 进程通信流程
    - 在通信进程间建立通信链路
    - 通过send/receive交换信息
- 进程链路特征
    - 物理（如，共享内存，硬件总线）
    - 逻辑（如，逻辑属性）



### 通信方式

![1e8fd4fc-5c30-4465-85cc-1b2f5cbad6da.png](https://storage.live.com/items/D2F4C87291B41CFE!1596888?authkey=AONVyty4CuEfbG8)



### 直接通信

- 进程必须正确的命名对方
    - send(P, message) - 发送信息到进程P
    - receive(Q, message) - 从进程Q接受消息
- 通信链路的属性
    - 自动建立链路
    - 一条链路恰好对应一对通信进程
    - 每对进程之间只有一个链接存在
    - 链路可以是单向的，但通常为双向的



### 间接通信

通过操作系统维护的消息队列实现进程间的消息接收和发送

- 每个消息队列都有一个唯一的标识
- 只有共享了相同消息队列的进程，才能够通信

通信链路属性

- 只有共享了相同消息队列的进程，才建立连接
- 链接可以时单向或者双向
- 消息队列可以与多个进程相关联
- 每对进程可以共享多个消息队列

通信流程

- 创建一个新的消息队列
- 通过消息队列发送和接收消息
- 销毁消息队列

基本通信操作

- send(A, message) - 发送消息到队列A
- receive(A, message) - 从队列A接收消息



### 阻塞与非阻塞通信

进程通信可划分为阻塞（同步）或者非阻塞（异步）

阻塞通信

- 阻塞发送
- 阻塞接收

非阻塞通信

- 非阻塞发送
- 非阻塞接收



### 通信链路缓冲

进程发送的信息在链路伤可能有三种缓冲方式

- 0容量

    发送方必须等待接收方

- 有限容量

    通信链路缓冲队列满时，发送方必须等待

- 无限容量

    发送方不需要等待



## 信号

### 信号

- 进程间的软件中断通知和处理机制
- 如：SIGKILL, SIGSTOP, SIGCONT等



### 信号的接收处理

- 捕获（catch）：执行进程指定的信号处理函数被调用到
- 忽略（Ignore）：执行操作系统指定的缺省处理，如：进程终止、进程挂起等
- 屏蔽（Mask）：禁止进程接收和处理信号，可能是暂时的



### 不足

传送的信息量小，只有一个信号类型



### 信号的实现

![fd230609-6f0d-4722-b774-ab8e1805617e.png](https://storage.live.com/items/D2F4C87291B41CFE!1596889?authkey=AONVyty4CuEfbG8)



### 实例

![90a2f217-accb-4675-b9eb-3cd99e33fc09.png](https://storage.live.com/items/D2F4C87291B41CFE!1596890?authkey=AONVyty4CuEfbG8)



## 管道（pipe）

进程间基于内存文件的通信机制

- 子进程从父进程继承文件描述符
- 缺省文件描述符：0 stdin, 1 stdout, 2 stderr

进程不知道（或不关心！）的另一端

- 可能从键盘、文件、程序读取
- 可能写入到终端、文件、程序



### 与管道相关的系统调用

- 读管道：read(fd, buffer, nbytes)

    scanf()是基于他实现

- 写管道：write(fd, buffer, nbytes)

    printf()是基于他实现的

- 创建管道：pipe(rgfd)

    - rgfd是两个文件描述符组成的数组
    - rgfd[0]是读文件描述符
    - rgfd[1]是写文件描述符



### 实例

![d33ce99c-2262-4f60-b4f7-bf1c35f2adef.png](https://storage.live.com/items/D2F4C87291B41CFE!1596891?authkey=AONVyty4CuEfbG8)



## 消息队列

### 定义

消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制

- 每个消息（Message）是一个字节序列
- 相同标识的消息组成按先进先出的顺序组成一个消息队列（Message Queues）

![8304886e-dec0-461d-a777-999908c46fd4.png](https://storage.live.com/items/D2F4C87291B41CFE!1596892?authkey=AONVyty4CuEfbG8)



### 系统调用

![7a286da0-231a-438f-bbd1-60113b55dd83.png](https://storage.live.com/items/D2F4C87291B41CFE!1596893?authkey=AONVyty4CuEfbG8)



## 共享内存

共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制

- 进程
    - 每个进程都有私有内存地址空间
    - 每个进程的内存地址空间需要明确设置共享内存段
- 线程
    - 同一进程中的线程总是共享相同的内存地址空间

- 优点
    - 快速、方便的共享数据
- 不足
    - 必须使用额外的同步机制来协调数据访问



### 实现

![c23b351a-722a-4d6b-a95b-51203306b2a5.png](https://storage.live.com/items/D2F4C87291B41CFE!1596894?authkey=AONVyty4CuEfbG8)



### 共享内存系统调用

![image](https://tvax1.sinaimg.cn/large/005wgNfbgy1gei1lguwa8j30vy0lnaz1.jpg)