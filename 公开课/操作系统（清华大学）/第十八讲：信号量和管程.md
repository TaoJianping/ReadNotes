## 提纲

- 信号量
- 信号量使用
- 管程
- 经典同步问题



## 回顾

- 并发问题
  - 多线程并发导致资源竞争
- 同步概念
  - 协调多线程对共享数据的访问
  - 任何时刻只能有一个线程执行临界区代码
- 确保同步正确的方法
  - 底层硬件支持
  - 高层次的编程抽象

![image](https://ws4.sinaimg.cn/large/005wgNfbgy1g6us11zc2uj31hc0u0auj.jpg)

![image](https://ws3.sinaimg.cn/large/005wgNfbgy1g6us2jsvxvj310b0mz4c0.jpg)



## 信号量（semaphore）

- 信号量是操作系统提供的一种协调共享资源访问的方法
  - 软件同步是平等线程间的一种同步协商机制
  - OS是管理者，地位高于进程
  - 用信号量表示系统资源的数量
- 由Dijkstra在20世纪60年代提出
- 早期的操作系统的主要同步机制
  - 现在很少用，但还是非常重要的在计算机科学研究中



#### 信号量是一种抽象数据类型

- 由一个整形（sem）变量和两个原子操作组成
- P()（Prolaag 荷兰语尝试减少）
  - sem减1
  - 如果sem<0，进入等待，否则继续
- V()（Verhoog 荷兰语增加）
  - sem加1
  - 如果sem<=0，唤醒一个等待进程



#### 信号量的特性

- 信号量是被保护的整数变量
  - 初始化完成后，只能通过P()和V()操作修改
  - 由操作系统保证，PV操作是原子操作
- P()可能阻塞，V()不会阻塞
- 通常假定信号量是“公平的”
  - 线程不会被无限期阻塞在P()操作
  - 假定信号量等待按先进先出排队



#### 信号量的实现

```c++
class Semaphore {
    int sem;
    WaitQueue q;
}


Semaphore::P () {
    sem--;
    if (sem < 0) {
        Add this thread t to q;
        block(t);
    }
}

Semaphore::V() {
    sem++;
    if (sem <= 0) {
        Remove a thread t from q;
        WakeUp(t);
    }
}
```



## 信号量使用

#### 信号量的分类

- 可分为两种信号量
  - 二进制信号量：资源数目为0或1
  - 资源信号量：资源数目为任何非负值
  - 两者等价
    - 基于一个可以实现另一个
- 信号量的使用
  - 互斥访问
    - 临界区的互斥访问控制
  - 条件同步
    - 线程间的时间等待



#### 用信号量实现临界区的互斥访问

每类资源设置一个信号量，其初值为1

```c++
auto mutex = new Semaphore(1);

mutex->P();
Critical Section;
mutex->V();
```

必须成对使用P()操作和V()操作

- P()操作保证互斥访问临界资源
- V()操作在使用后释放临界资源
- PV操作不能次序错误、重复或者遗漏



#### 用信号量实现条件同步

![image](https://wx2.sinaimg.cn/large/005wgNfbgy1g6usyo3ftgj30ly0f8n3x.jpg)

当你需要运行完线程B的X，才能运行线程A的N，那你就可以先初始化一个信号量0，然后只有当X运行完成，才能对condition进行V()。具体看视频，讲的很清楚。



#### 用信号量解决生产者消费者问题

- 有界缓冲区的生产者-消费者问题描述
  - 一个或者多个生产者在生成数据后放到一个缓冲区里面
  - 单个消费者从缓冲区取出数据处理
  - 任何时刻只能有一个生成者和消费者可以访问缓冲区
- 问题分析
  - 任何时刻只能有一个线程操作缓冲区（互斥访问）
  - 缓冲区空时，消费者必须等待生产者（条件同步）
  - 缓冲区满时，生产者必须等待消费者（条件同步）
- 用信号量描述每个约束
  - 二进制信号量mutex
  - 资源信号量fullBuffers
  - 资源信号量emptyBuffers

###### 代码

```c++
class BoundedBuffer {
    mutex = new Semaphore(1);
    fullBuffers = new Semaphore(0);
    emptyBuffers = new Semaphore(n);
}

BoundedBuffer::Deposit(c) {
    emptyBuffers->P();
    mutex->P();
    Add c to the buffer;
    mutex->V();
    fullBuffers->V();
}

BoundedBuffer::Remove(c) {
    fullBuffers->V();
    mutex->P();
    Remove c from buffer;
    mutex->V();
    emptyBuffers->P();
}
```



#### 使用信号量的困难

- 读/开发代码比较困难
  - 程序员需要能运用信号量机制
- 容易出错
  - 使用的信号量已经被另一个线程占用
  - 忘记释放信号量
- 不能够处理死锁问题