### 学习目标

- 页面置换算法的概念
- 局部页面置换算法
  - 最优页面置换算法（OPT，optimal）
  - 先进先出算法（FIFO）
  - 最近最久未使用算法（LRU，Least Recently Used）
  - 时钟页面置换算法（Clock）
  - 最不常用算法（LFU，Least Frequently Used）
  - Belady现象
  - LRU，FIFO和Clock的比较
- 全局页面置换算法
  - 工作集置换算法
  - 缺页率置换算法
  - 抖动和负载控制



### 页面置换算法的概念

##### 功能

当出现缺页异常，需要调入新页面而内存已满时，置换算法选择被置换的物理页面



##### 设计目标

- 尽可能的减少页面的调入调出次数
- 把未来不再访问或者短期内不访问的页面调出



##### 页面锁定（frame locking）

- 描述必须常驻内存的逻辑页面
- 操作系统的关键部分
- 要求响应速度的代码和数据
- 页表中的锁定标志位（lock bit）



##### 置换算法的评价方法

- 模拟页面置换行为，记录产生缺页的次数
- 更少的缺页，更好的性能



##### 页面置换算法分类

- 局部页面置换算法
  - 置换页面的选择范围仅限于当前进程占用的物理页面内
  - 最优算法，先进先出算法，最近最久未使用算法
  - 时钟算法，最不常用算法
- 全局页面置换算法
  - 置换页面的选择范围是所有可换出的物理页面
  - 工作集算法，缺页率算法





## 局部页面置换算法

### 最优算法

##### 基本思路

- 置换在未来最长时间不访问的页面

##### 算法实现

- 缺页时，计算内存中每个逻辑页面的下一次访问时间
- 选择未来最长时间不访问的页面

##### 算法特征

- 缺页最少，是理想情况
- 实际系统中无法实现，因为无法预知每个页面在下次访问前的等待时间

##### 实例

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596110?authkey=AONVyty4CuEfbG8)



### 先进先出算法（First-In First-Out，FIFO）

##### 思路

- 选择在内存驻留时间最长的页面进行置换

##### 实现

- 维护一个记录所有位于内存中的逻辑页面的链表
- 链表元素按驻留内存的时间排序，链首最长，链尾最短
- 出现缺页的时候，选择链首页面进行置换，新页面添加到链尾

##### 特征

- 实现简单
- 性能较差，调出的页面可能是经常访问的
- 进程分配物理页面数增加时，缺页并不一定减少，会触发belady现象
- 很少单独使用

##### 实例

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596111?authkey=AONVyty4CuEfbG8)





### 最近最久未使用算法（Least Recently Used，LRU）

##### 思路
- 选择最长时间没有被引用的页面进行置换
- 如果某些页面长时间未被访问，则他们在将来还可能会长时间不会访问

##### 实现

- 缺页时，计算内存中的每个逻辑页面的上一次访问时间
- 选择上一次使用到当前页面最长的页面

##### 特征

- 最优算法的一种近似
- 可能实现的方法开销都很大

##### 可能的实现方法

- 页面链表
  - 系统维护一个按最近一次访问时间排序的页面链表
    - 链表首节点是最近刚刚使用过的页面
    - 链表尾节点是最久未使用的页面
  - 访问内存时，找到相应的页面，把他移动到链表之首
  - 缺页时，置换链表尾节点的页面
- 活动页面栈
  - 访问页面时，将此页面压入栈顶，并栈内相同页面去除
  - 缺页时，置换栈底的页面

##### 实例

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596112?authkey=AONVyty4CuEfbG8)

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596113?authkey=AONVyty4CuEfbG8)





### 时钟置换算法（Clock）

##### 思路
- 仅对页面的访问情况进行大致统计
##### 数据结构
- 在页表项中增加访问位，描述页面在过去一段时间的内存访问情况
- 各页面组织成环形链表
- 指针指向最先调入的页面
##### 算法
- 访问页面时，在页表项记录页面的访问情况
- 缺页时，从指针处开始顺序查找未被访问的页面进行置换

##### 特征

- 时钟算法算是LRU和FIFO的折中

##### 时钟置换算法的具体实现

- 页面装入内存时，访问位初始化为0
- 访问页面（读/z`）时，访问位置为1
- 缺页时，从指针当前位置顺序检查环形链表
  - 访问位为0，则置换该页
  - 访问位为1，则访问位置0，并指针移动到下个页面，直到找到可置换的页面

##### 改进的Clock算法

思路

- 减少修改页的缺页处理开销

算法

- 在页面中增加修改位，并在访问时进行相应的修改
- 缺页时，修改页面标志位，以跳过有修改的页面

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596114?authkey=AONVyty4CuEfbG8)

##### 实例

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596115?authkey=AONVyty4CuEfbG8)

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596116?authkey=AONVyty4CuEfbG8)





### 最不常用算法（Least Frequently Used，LFU）

##### 思路

- 缺页时，置换访问次数最少的页面



##### 实现

- 每个页面设置一个访问计数
- 访问页面时，访问计数加1
- 缺页时，置换计数最小的页面



##### 特征

- 算法开销大
- 开始时频繁使用，但以后不使用的页面很难置换
  - 解决方法：计数定期右移



##### LRU和LFU的区别

- LRU关注多久未访问，时间越短越好
- LFU关注访问次数，次数越多越好



##### 实例

![image](https://storage.live.com/items/D2F4C87291B41CFE!1596117?authkey=AONVyty4CuEfbG8)





### Belady现象

##### 现象

- 采用FIFO等算法的时候，可能出现分配的物理页面数增加，缺页次数反而升高的异常现象

##### 原因

- FIFO算法的置换特征与进程访问内存的动态特征矛盾
- 被他置换出去的页面不一定时进程近期不会访问的



这个是一个叫Belady的人发现的现象，所以叫这个名字，具体是指随着物理页分配的增多，反而可能出现缺页率的上升，本质上是分配算法和命中页没有相关性，多出现于FIFO算法

下面是官方解释

> 所谓Belady现象是指：在分页式虚拟存储器管理中，发生缺页时的置换算法采用FIFO（[先进先出](https://baike.baidu.com/item/先进先出/9629304)）算法时，如果对一个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。
>
> Belady现象的描述：一个进程P要访问M个页,OS分配N(N<M)个内存页面给进程P;对一个访问序列S,发生缺页次数为PE(S,N).当N增大(且N小于M)时,PE(S, N)时而增大,时而减小。
>
> FIFO是最早出现的页置换算法之一。Belady现象的原因是FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，即被置换的页面并不是进程不会访问的，因而FIFO并不是一个好的置换算法。
>
> Belady和抖动并不完全一样。





### LRU、FIFO和Clock的比较

- LRU算法和FIFO算法本质上都是先进先出的思路
  - LRU依据页面的最近访问时间排序
  - LRU需要动态的调整顺序
  - FIFO依据页面进入内存的时间排序
  - FIFO的页面进入时间是固定不变
- LRU可退化成FIFO
  - 如页面进入内存后没有被访问，最近访问时间与进入内存的时间相同
- LRU算法性能较好，但是开销较大
- FIFO算法系统开销较小，会发生Belady现象
- Clock算法是他们的折衷
  - 页面访问时，不动态调整页面在链表中的顺序，仅做标记
  - 缺页时，再把它移动到链表末尾
- 对于未被访问的页面，Clock和LRU算法的表现一样好
- 对于被访问过的页面，Clock算法不能记录准确访问顺序，而LRU算法可以