## 函数对象

 一个函数对象，即一个重载了括号操作符“（）”的对象。当用该对象调用此操作符时，其表现形式如同普通函数调用一般，因此取名叫函数对象。

示例：

```c++
class TestFunc {
public:
    void operator() () {
        cout << "hello TestFunction" << endl;
    }
};


int main() {
    TestFunc func;
    func();
    return 0;
}
```

注意这个重载仍然是作用于这个类所生成的对象的，而不是这个类。



#### 函数对象的优势

1. 函数对象可以保存自己的状态，因为实际上就是个类所生成的实例而已。数对象可以有自己的状态。我们可以在类中定义状态变量，这样一个函数对象在多次的调用中可以共享这个状态。但是函数调用没这种优势，除非它使用全局变量来保存状态。
2. 函数对象有自己特有的类型，而普通函数无类型可言。这种特性对于使用C++标准库来说是至关重要的。



有一点需要指出的是，在调用用到函数对象的标准库算法时，除非显式地指定模板类型为“传引用”，否则默认情况下函数对象是”**按值传递**“的！因此，如果传递的是一个具有内部状态的函数对象，则被改变状态的是函数内部被复制的临时对象，函数结束后随之消失。真正传进来的函数对象状态并为改变。



## 函数指针

函数指针：是指向函数的指针变量，在C编译时，每一个函数都有一个入口地址，那么这个指向这个函数的函数指针便指向这个地址。

函数指针的用途是很大的，主要有两个作用：用作调用函数和做函数的参数。

函数指针的声明方法：
数据类型标志符 （指针变量名） （形参列表）；

一般函数的声明为: 
int func ( int x );

而一个函数指针的声明方法为：
int (*func) (int x);

前面的那个(*func)中括号是必要的，这会告诉编译器我们声明的是函数指针而不是声明一个具有返回型为指针的函数，后面的形参要视这个函数指针所指向的函数形参而定。
然而这样声明我们有时觉得非常繁琐，于是typedef可以派上用场了，我们也可以这样声明：
typedef int (*PF) (int x);
PF pf;
这样pf便是一个函数指针，方便了许多。当要使用函数指针来调用函数时，func(x)或者  (*fucn)(x) 就可以了，当然，函数指针也可以指向被重载的函数，编译器会为我们区分这些重载的函数从而使函数指针指向正确的函数。

```c
typedef void (*PFT) ( char ,int );
void bar(char ch, int i)
{
    cout<<"bar "<<ch<<' '<<i<<endl;
    return ;
}
PFT pft;
pft = bar;
pft('e',91);
```

```cpp
#include <iostream>
int add(int a, int b){
    return a+b;
}
int sub(int a, int b){
    return a-b;
}
void func(int e, int d, int(*f)(int a, int b)){ // 这里才是我想说的，
// 传入了一个int型，双参数，返回值为int的函数
    std::cout<<f(e,d)<<std::endl;
}
int main()
{
    func(2,3,add);
    func(2,3,sub);

    return 0;
}
```