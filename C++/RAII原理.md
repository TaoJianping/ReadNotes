# RAII

> RAII 字面意思是说在对象构造的时候获取资源，其实更本质的含义是：让对象拥有（own）资源，在析构的时候释放资源，这样资源的生命期管理就和对象生命期管理统一起来，只要做到不泄漏对象，就能保证不泄漏资源。



RAII是resource acquisition is initialization的缩写，意为“资源获取即初始化”。它是C++之父Bjarne Stroustrup提出的设计理念，其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在RAII的指导下，C++把底层的资源管理问题提升到了对象生命周期管理的更高层次。

说起来，RAII的含义倒也不算复杂。用白话说就是：在类的构造函数中分配资源，在析构函数中释放资源。这样，当一个对象创建的时候，构造函数会自动地被调用；而当这个对象被释放的时候，析构函数也会被自动调用。于是乎，一个对象的生命期结束后将会不再占用资源，资源的使用是安全可靠的。



C++ RAII体现出了简洁、安全、实时的特点：

1. 概念简洁性：让资源（包括内存和非内存资源）和对象的生命周期绑定，资源类的设计者只需用在类定义内部处理资源问题，提高了程序的可维护性
2. 类型安全性：通过资源代理对象包装资源（指针变量），并利用运算符重载提供指针运算方便使用，但对外暴露类型安全的接口
3. 异常安全性：栈语义保证对象析构函数的调用，提高了程序的健壮性
4. 释放实时性：和GC相比，RAII达到了和手动释放资源一样的实时性，因此可以承担底层开发的重任



#### RAII 总结:

- 将每个资源封装入一个类，其中
  - 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，
  - 析构函数释放资源并决不抛出异常；

- 始终经由 RAII 类的实例使用满足要求的资源，该资源
  - 自身拥有自动存储期或临时生存期，或
  - 具有与自动或临时对象的生存期绑定的生存期



#### 实例代码

```c++
std::mutex m;
 
void bad() 
{
    m.lock();                    // 请求互斥体
    f();                         // 若 f() 抛异常，则互斥体永远不被释放
    if(!everything_ok()) return; // 提早返回，互斥体永远不被释放
    m.unlock();                  // 若 bad() 抵达此语句，互斥才被释放
}
 
void good()
{
    std::lock_guard<std::mutex> lk(m); // RAII类：互斥体的请求即是初始化
    f();                               // 若 f() 抛异常，则释放互斥体
    if(!everything_ok()) return;       // 提早返回，互斥体被释放
}     
```

上面的这个代码就可以看到，RAII的本质是你资源的生命周期必须要和你的对象的生命周期所绑定，当你的对象析构消失的时候，这个资源也就随着你的对象一起被释放了，上面的两个示例就清楚的展现了他们之间的差别。具体来说说bad里面的，想象一下，如果函数提前返回或者发生异常了，他的释放资源的语句m.unlock()就没有运行到，资源就没有正常释放了，这个是很不对的。



## 参考

https://zh.cppreference.com/w/cpp/language/raii

https://zh.wikipedia.org/wiki/RAII

http://www.cppblog.com/aaxron/archive/2011/03/22/142475.html

https://oxnz.github.io/2015/07/23/cpp-raii/