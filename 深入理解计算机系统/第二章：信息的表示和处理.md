# 第二章：信息的表示和处理

#### C语言中的移位运算

- 左移
- 逻辑右移：向右移动k位，丢弃k位，插入k个0
- 算术右移：向右移动k位，丢弃k位，插入k个最高有效位



#### 补码、反码和原码

原码：原码就是最高位为符号位，其他为数据。

> [+1]原 = 0000 0001
>
> [-1]原 = 1000 0001

所以说他的取值范围是[-127, 127]。



反码：就是正数保持不变，负数保持最高位，即符号位不变，其他位直接去反。

> [+1] = [00000001]原 = [00000001]反
>
> [-1] = [10000001]原 = [11111110]反



补码：正数保持不变，负数保持符号位不变，其他位置取反再加1

> [+1] = [00000001]原 = [00000001]反 = [00000001]补
>
> [-1] = [10000001]原 = [11111110]反 = [11111111]补



> **2的补码的本质**
>
> 在回答2的补码为什么能正确实现加法运算之前，我们先看看它的本质，也就是那两个步骤的转换方法是怎么来的。
>
> 要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。
>
> 已知8的二进制是00001000，-8就可以用下面的式子求出：
>
> 　００００００００
> －００００１０００
> －－－－－－－－－
>
> 因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。
>
> 所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，算式也就改写成：
>
> １００００００００
> －００００１０００
> －－－－－－－－－
> 　１１１１１０００
>
> 进一步观察，可以发现100000000 = 11111111 + 1，所以上面的式子可以拆成两个：
>
> 　１１１１１１１１
> －００００１０００
> －－－－－－－－－
> 　１１１１０１１１
> ＋０００００００１
> －－－－－－－－－
> 　１１１１１０００
>
> 2的补码的两个转换步骤就是这么来的。
>
> **为什么正数加法适用于2的补码？**
>
> 实际上，我们要证明的是，X-Y或X+(-Y)可以用X加上Y的2的补码完成。
>
> Y的2的补码等于(11111111-Y)+1。所以，X加上Y的2的补码，就等于：
>
> X + (11111111-Y) + 1
>
> 我们假定这个算式的结果等于Z，即 Z = X + (11111111-Y) + 1
>
> 接下来，分成两种情况讨论。
>
> 第一种情况，如果X小于Y，那么Z是一个负数。这时，我们就对Z采用2的补码的逆运算，求出它对应的正数绝对值，再在前面加上负号就行了。所以，
>
> Z = -[11111111-(Z-1)] = -[11111111-(X + (11111111-Y) + 1-1)] = X - Y
>
> 第二种情况，如果X大于Y，这意味着Z肯定大于11111111，但是我们规定了这是8位机，最高的第9位是溢出位，必须被舍去，这相当于减去100000000。所以，
>
> Z = Z - 100000000 = X + (11111111-Y) + 1 - 100000000 = X - Y
>
> 这就证明了，在正常的加法规则下，可以利用2的补码得到正数与负数相加的正确结果。换言之，计算机只要部署加法电路和补码电路，就可以完成所有整数的加法。