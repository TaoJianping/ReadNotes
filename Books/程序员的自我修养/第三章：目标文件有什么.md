# 目标文件有什么

- 目标文件的格式
- 目标文件是什么样的
- 挖掘SimpleSection.o
- ELF文件结构描述
- 链接的接口-符号
- 调试信息
- 本章小结

编译器编译源代码生成的文件叫做**目标文件**，目标文件从结构上讲，他是已经编译后的可执行文件，只是还没有经过链接的过程，有些符号或者地址没有调整。



## 3.1 目标文件的格式

目前PC平台流行的可执行文件格式（Executable）:

- PE（Portable Executable）
- ELF（Executable Link Format）

他们都是COFF（Common file format）的变种。

⽬标⽂件就是源代码编译后但未进⾏链接的那些中间⽂件（Windows的.obj和Linux下的.o），它
跟可执⾏⽂件的内容与结构很相似，所以⼀般跟可执⾏⽂件格式⼀起采⽤⼀种格式存储。

![image](https://tva4.sinaimg.cn/large/005wgNfbgy1ga0o8wpz0kj30p20imh4a.jpg)



## 3.2 目标文件是什么样的

⽬标⽂件中的内容⾄少有编译后的**机器指令代码**、**数据**。没错，除了这些内容以外，⽬标⽂件中还包括了链接时所须要的⼀些信息，⽐如**符号表、调试信息、字符串**等。

一般目标文件将这些信息按不同的属性，以“节”（section）或“段”（segment）的形式存储。

![image](https://tva1.sinaimg.cn/large/005wgNfbgy1ga0osepi0zj30rs0pfn4r.jpg)



### ELF File Header

ELF⽂件的开头是⼀个“⽂件头”，它描述了整个⽂件的⽂件属性，包括⽂件是否可执⾏、是静态链接还是动态链接及⼊⼜地址（如果是可执⾏⽂ 件）、⽬标硬件、⽬标操作系统等信息，⽂件头还包括⼀个段表（Section Table），段表其实是⼀个描述⽂件中各个段的数组。段表描述了⽂件中各 个段在⽂件中的偏移位置及段的属性等，从段表⾥⾯可以得到每个段的所有信息。



### 代码段（Code Section）

程序源代码编译后的机器指令经常被放在代码段（Code Section）⾥，代码 段常见的名字有“.code”或“.text”。



### 数据段（Data Section）

全局变量和局部静态变量数据经常放在 数据段（Data Section）



### BSS

未初始化的全局变量和局部静态变量⼀般放在⼀个叫“.bss”的段⾥。所以.bss段只是为未初始化的全局变量和局部静态变量预留位置 ⽽已，它并没有内容，所以它在⽂件中也不占据空间



数据和指令分段的好处有 很多。主要有如下几个方面：

- ⼀⽅⾯是当程序被装载后，数据和指令分别被映射到两个虚存区域。由 于数据区域对于进程来说是可读写的，⽽指令区域对于进程来说是只读 的，所以这两个虚存区域的权限可以被分别设置成可读写和只读。这样可以防⽌程序的指令被有意或⽆意地改写。
- 另外⼀⽅⾯是对于现代的CPU来说，它们有着极为强⼤的缓存（Cache），由于缓存在现代的计算机中地位⾮常重要，所以程序必须尽量提⾼缓存的命中率。指令区和数据区的分离有利于提⾼程序的局部性。现代 CPU的缓存⼀般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据被分开存放对CPU的缓存命中率提⾼有好处。
- 第三个原因，其实也是最重要的原因，就是当系统中运⾏着多个该程序的副本时，它们的指令都是⼀样的，所以内存中只须要保存⼀份该程序的指令部分。对于指令这种只读的区域来说是这样，对于其他的只读数据也 ⼀样，⽐如很多程序⾥⾯带有的图标、图⽚、⽂本等资源也是属于可以共享的。当然每个副本进程的数据区域是不⼀样的，它们是进程私有的。不要小看这个共享指令的概念，它在现代的操作系统⾥⾯占据了极为重要的地位，特别是在有动态链接的系统中，可以节省⼤量的内存。



![image](https://tva2.sinaimg.cn/large/005wgNfbly1ga0q3kxd48j30px0hmzxt.jpg)



## 3.4 ELF文件结构描述

![image](https://tvax1.sinaimg.cn/large/005wgNfbly1ga0qcdzh9ij30el0jzwfv.jpg)



### 3.4.1 文件头（ELF File Header）

ELF⽂件头结构及相关常数被定义在“/usr/include/elf.h”⾥，因为ELF⽂件在 各种平台下都通⽤，ELF⽂件有32位版本和64位版本。

“elf.h”使⽤typedef定义了⼀套⾃⼰的变量体系:

![image](https://tvax4.sinaimg.cn/large/005wgNfbly1ga1tv9qo9ij30k80agqae.jpg)

下面这个是32位的ELF header

```c
typedef struct
{
    unsigned char e_ident[16];
    Elf32_Half e_type;
    Elf32_Half e_machine;
    Elf32_Word e_version;
    Elf32_Addr e_entry;
    Elf32_Off e_phoff;
    Elf32_Off e_shoff;
    Elf32_Word e_flags;
    Elf32_Half e_ehsize;
    Elf32_Half e_phentsize;
    Elf32_Half e_phnum;
    Elf32_Half e_shentsize;
    Elf32_Half e_shnum;
    Elf32_Half e_shstrndx;
} Elf32_Ehdr;
```

![image](https://tvax4.sinaimg.cn/large/005wgNfbly1ga1twr4k8xj30lr0kmqeq.jpg)



ELF header 魔数的意义

![image](https://tva1.sinaimg.cn/large/005wgNfbly1ga1tys477lj30mu0hpjv6.jpg)



下面是个例子：

```
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          1112 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         13
  Section header string table index: 12
```



