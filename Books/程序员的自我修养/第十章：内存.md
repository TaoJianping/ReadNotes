#  第十章：内存

## 10.1 程序的内存布局

- 用户空间
- 内核空间
- 栈：栈⽤于维护函数调⽤的上下⽂，离开了栈函数调⽤就没法实现。
- 堆：堆是⽤来容纳应⽤程序动态分配的内存区域，当程序使⽤malloc或new分配内存时，得到的内存来⾃堆⾥。
- 可执行文件映像：这⾥存储着可执⾏⽂件在内存⾥的映像（Chapter 6）
- 保留区：保留区并不是⼀个单⼀的内存区域，⽽是对内存中受到保护⽽禁⽌访问的内存区域的总称。
- 动态链接库映射区：“动态链接库映射区”，这个区域⽤于映射装载的动态链接库。在Linux下，如果可执⾏⽂件依赖其他共享库，那么系统就会为它在从0x40000000开始的地址分配相应的空间，并将共享库载⼊到该空间。

![image](https://tva4.sinaimg.cn/large/005wgNfbly1gaj85fpxrnj30i80og105.jpg)



## 10.2 栈与调用惯例

### 10.2.1 什么是栈

栈保存了⼀个函数调⽤所需要的维护信息，这常常被称为堆栈帧（Stack Frame）或活动记录
（Activate Record）。栈顶由esp指针进行定位。



#### 堆栈帧

- 函数的返回地址和参数
- 临时变量：包括函数的⾮静态局部变量以及编译器⾃动⽣成的其他临时变量。
- 保存的上下⽂：包括在函数调⽤前后需要保持不变的寄存器。



在i386中，⼀个函数的活动记录⽤ebp和esp这两个寄存器划定范围。esp寄存器始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部。⽽相对的，ebp寄存器指向了函数活动记录的⼀个固定位置，ebp寄存器又被称为帧指针（Frame Pointer）。⼀个很常见的活动记录⽰例如图10-4所⽰。

![image](https://tva3.sinaimg.cn/large/005wgNfbgy1gajrl3ijn9j30d40dawey.jpg)



一个i386下的函数是这样调用的

- 把所有或⼀部分参数压⼊栈中，如果有其他参数没有⼊栈，那么使⽤某些特定的寄存器传递。
- 把当前指令的下⼀条指令的地址压⼊栈中。
- 跳转到函数体执⾏。
- push ebp：把ebp压⼊栈中（称为old ebp）。
- mov ebp, esp：ebp = esp（这时ebp指向栈顶，⽽此时栈顶就是old ebp）；
- 【可选】sub esp, XXX：在栈上分配XXX字节的临时空间。
- 【可选】push XXX：如有必要，保存名为XXX寄存器（可重复多个）。
- Function Body，具体的函数执行
- 【可选】pop XXX：如有必要，恢复保存过的寄存器（可重复多个）。
- mov esp, ebp：恢复ESP同时回收局部变量空间。
- pop ebp：从栈中恢复保存的ebp的值。
- ret：从栈中取得返回地址，并跳转到该位置。



### 10.2.2 调用惯例

无论函数的调用放还是被调用方都维护了一个调用的约定，这样才可以保证在函数调用的时候不会出错。这样的约定就叫做**调用惯例（Calling Conversion）**。

- 函数参数的传递顺序和方式
- 栈的维护方式
- 名字修饰（Name-mangling）的策略



### 10.2.3 函数返回值传递

- 四个字节的就通过eax返回。
- 4-8个字节的就用eax和edx联合返回，eax存储底4位，edx存储高4位。
- 如果超过8个字节
  - 首先调用者的栈上开辟一段空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为temp。
  - 将temp对象的地址当作隐藏参数传递给被调用函数。
  - 被调用函数将数据拷贝给temp对象，并将temp对象的地址用eax传出。
  - 返回之后，main函数将eax指向的temp对象拷贝给返回值。



## 10.3 堆与内存惯例

没啥