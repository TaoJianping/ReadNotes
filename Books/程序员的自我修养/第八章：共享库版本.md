# 第八章：Linux共享库的组织

- 8.1 共享库的版本
- 8.2 符号版本
- 8.3 共享库系统路径
- 8.4 共享库查找过程
- 8.5 环境变量
- 8.6 共享库的创建和安装
- 本章总结



## 8.1 共享库版本

### 8.1.1 共享库兼容性

主要讨论的是ABI的兼容性。



### 8.1.2 共享版本的命名

Linux的共享库的命名规则

***libname.so.x.y.z***

最前面使用前缀“lib”、中间是库的名字和后缀".so"，最后的是三个数字组成的版本号

- “x”代表的是主版本号（Major Version Number）
- “y”代表的是次版本号（Minor Version Number）
- “z”代表的是发布版本号（Release Version Number）

主版本号不保证兼容，次版本号保证兼容，就算新增一些接口，发布版本号就是一些bug fix之类的，也不对接口进行更改。



### 8.1.3 SO-NAME

共享库的主版本号和次版本号决定了一个共享库的接口。

Linux采用了一个叫**SO-NAME**的命名机制来记录共享库的依赖关系，每个共享库都有一个对应的“SO-NAME”。这个“SO-NAME”的规则就是：

> 共享库的文件名去掉次版本号和发布版本号，保留主版本号。

很明显，“SO-NAME”规定了共享库的接口，只要SO-NAME名字相同，就保证了兼容。

在Linux中，系统会为每个共享库在它所在的目录创建一个跟SO-NAME相同的并且只想他的软连接。保证这个软链接每次都能指向最新的共享库，并且保证主版本号相同就行。

目的就是所有依赖某个共享库的模块，在编译、链接和运行的时候，都是用共享的SO-NAME，而不用详细的版本号。

> 总之：
>
> SO-NAME表示一个库的接口，接口不向后兼容，SO-NAME就发生变化，这就是最基本的原则。



## 8.2 符号版本

其实一开始的时候是详细记录版本的全名的，即知道它的具体版本号，而在链接编译装载的时候，他会做检查，如果有问题，有两种策略：

- 报错
- 阻止运行

在采用第二种策略的系统中，如果只有低版本的共享库，他是无法运行的，这叫做**次版本交会问题（Minor-revision Rendezvous Problem）**。

次版本交会问题没有因为SO-NAME的引入而解决，因为次版本只保证向后兼容，而不保证向前兼容。所以我们引入**符号版本机制**。



### 8.2.1 基于符号的版本机制

#### 基于符号的版本机制(Symbol Versioning)

这个方案的基本思路就是让每个导出和导入的符号都有一个相关联的新版本号。



### 8.2.2 Solaris 的符号版本机制

版本机制的想法很简单，就是定义一些符号的结合，这些集合本身就有名字。

> 在Solaris中程序员可以写符号版本脚本文件来指定这些符号的集合集成关系。

```c
SUNW_1.1 {
    global:
    	pop;
    	push;
}

SUNWprivate {
    global:
    	__pop;
    	__push;
    local:
    	*
}

SUNW_1.2{
    global:
    	swap;
} SUNW_1.1
```

##### 范围机制（Scoping）

就是指定哪些符号是全局的，哪些是私有的，比如上面文件中的`global`和`local`关键字。



当我们有了这些版本符号集合的时候，链接器会选择最小程序所依赖的符号的集合的最小版本，如果SUNW_1.1合适，就用它。



### 8.2.3 Linux中的符号版本

Linux下面并没有广泛应用，用的最多的是Glibc，并且进行了两个拓展

- GCC允许使用一个叫做`.symver`的汇编宏指令来指定符号的版本
- GCC允许多个版本的同一个符号存在于一个共享库中



## 8.3 共享库系统路径

现在很多开源系统都支持一个叫做**FHS（File Hierarchy Standard）**的标准，规定了一个系统中的文件应该如何存放。

- lib
- /usr/lib
- /usr/local/lib



## 8.4 共享库查找过程

- 如果`.dynamic`的DT_NEED中有绝对路径，就按照这个路径找
- 如果DT_NEED是相对路径，那么按照`/lib`，`/usr/lib`和`/etc/ld.so.conf`指定的目录中找。

### ldconfig

这个程序的作用是为了共享库目录下的各个共享库创建、删除或更新相应的SO-NAME（即相应的符号链接），这样每个共享库的SO-NAME能够只想正确的共享库文件

### /etc/ld.so.cache

并且这个程序还会讲这些SO-NAME收集起来，集中放到/etc/ld.so.cache文件里面，并建立一个SO-NAME的缓存。



## 8.5 环境变量

### LD_LIBBARY_PATH

如果我们为某个进程设置了LD_LIBBARY_PATH，那么进程在启动的时候，会首先查找这个参数指定的目录。

#### 方法一

```shell
$ LD_LIBBARY_PATH=/home/user /bin/ls
```

#### 方法二

```shell
$ /lib/ld-linux.so.2 -library-path /home/user /bin/ls
```

但是这个东西千万不能被滥用，有相关的文章讲这个，看书上有相应的页面，在P243。



### LD_PRELOAD

优先级比上面的还高，而且无论用得上的符号还是用不上的全部会装载。会覆盖后面同名的符号，方便调试，但是也不应该被滥用



### LD_DEBUG

这个环境变量可以帮我们打开动态链接器的调试功能，打印各种有用的信息。

具体看书P244，有详细的参数。

