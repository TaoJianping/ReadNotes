# 第七章：动态链接

- 7.1 为什么要动态链接
- 7.2 简单的动态链接例子
- 7.3 地址无关代码
- 7.4 延迟绑定（PLT）
- 7.5 动态链接相关结构
- 7.6 动态链接的步骤和实现
- 7.7 显式运行时链接



## 7.1 为什么要动态链接

- 浪费内存空间和磁盘空间
- 模块更新困难
- 可拓展性兼容性差

把链接这个过程推迟到运行时再进行，这就是**动态链接（Dynamic Linking）**的基本思想。

### 动态链接的基本实现

在Linux系统中，ELF动态链接文件被称为**动态共享对象（Dynamic Shared Objects）**，简称共享对象，他们一般是以“.so”为拓展名的一些文件；在Windows系统中，动态文件则是DLL。

当程序被装载的时候，系统的**动态链接器**会将程序所需的所有的动态链接库装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。



## 7.2 简单的动态链接例子

![image](https://tvax1.sinaimg.cn/large/005wgNfbgy1gaf2rumv9qj30k60g6wgt.jpg)

如果一个函数定义在某个动态共享对象中，那么链接器会将这个符号的引用标记为一个动态链接的符号，不对他进行地位重定位，把这个过程留到装载时进行。

### 动态链接器

动态链接器与普通共享对象一样被映射到进程的地址空间，在系统开始运行Program之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给Program，然后开始执行。

共享对象的最终装载地址在编译时是不确定的。



## 7.3 地址无关代码

### 7.3.1 固定装载地址的困扰（！！！）

> 共享对象在被装载时，如何确定它在进程虚拟地址空间中的位置？

#### 静态共享库（Static Shared Library）

静态共享库的做法就是将程序的各个模块统一交给操作系统来管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。

##### 问题

- 地址冲突
- 升级困难

为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在任意地址加载？即：

- 共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。



### 7.3.2 装载时重定位

因为固定装载地址不大合适，所以我们可以：

- 在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序所有的绝对地址引用进行重定位。

这种就叫做**装载时重定位（Load Time Relocation）**，而我们在前面静态链接时提到过重定位，那时的重定位叫做**链接时重定位（Link Time Relocation）**。

但是他也有缺点：

- 没有办法做到同一份指令被多个进程共享，这样就失去了动态链接节省内存的一大优势



### 7.3.3 地址无关代码

因为装载时重定位和固定装载地址都有自己的问题，所以我们就引入了**地址无关代码（PIC，Position-independent Code）**。基本的原理：

> 把指令中那些需要修改的部分分离出来，跟数据部分放在一起，这样指令的部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

分四种情况讨论：

- 第一种是模块内部的函数调用、跳转等；
- 第二种是模块内部的数据访问，比如模块内中定义的全局变量、静态变量；
- 第三种是模块外部的函数调用、跳转等；
- 第四种是模块外部的数据访问，比如其他模块中定义的全局变量；

```c
static int a;
extern int b;
extern void ext();

void bar()
{
    a = 1;		// Type 2
    b = 2;		// Type 4
}

void foo()
{
    bar();		// Type 1
    ext();		// Type 3
}
```

#### 类型一 模块内部调用或跳转

因为被调用的函数都处在同一个模块中，他们之间的相对位置是固定的，都在同一块代码块中，所以这种情况还是很简单的。对于现代的系统来讲，模块内部的跳转、函数调用都可以是**相对地址调用**，或者是基于**寄存器的相对调用**，所以对于这种指令是不需要重定位。

#### 类型二 模块内部数据访问

模块内部的数据访问，指令中不能直接包含数据的绝对地址，那么唯一的办法就是相对地址。

一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，也就是说，任何一条指令与他需要访问的模块内部数据之间的相对位置是固定的，那么只需要相对于当前指令加上固定的偏移量就可以访问模块内部的数据。

现代的体系结构中，数据的相对寻址往往没有相对于当前指令地址（PC）的寻址方式，所以ELF用了一个很巧妙的办法来得到当前的PC值，然后再加上一个偏移量就可以达到访问相应变量的目的了。得到PC值的方法很多。

> P193有详细的方法：这里简单说一下，就是通过调用一个函数你（call指令），你就可以只当当前的地址，然后把他放到ecx寄存器里面。这样就知道了。具体可以看书上，有具体的案例。



## 7.5 动态链接相关结构

在映射完可执行文件之后，操作系统会先启动一个**动态链接器（Dynamic Linker）**。

> 在Linux下，动态链接器ld.so实际上是一个共享对象，操作系统将他通过映射的方式加载到进程的地址空间中。



### 7.5.1 “.interp”段

动态链接器的位置是由ELF文件决定的，他有一个专门的段`interp`段来放具体的位置。里面的内容很简单，就是放了一个字符串，比如`/lib/ld-linux.so`，这个字符串就是可执行文件所在的路径。



### 7.5.2 “.dynamic”段

动态链接ELF中最重要的结构应该是`.dynamic`段，这个段里面保存了动态链接器所需要的基本信息比如：

- 依赖哪些共享对象
- 动态链接符号表的位置
- 动态链接重定位表的位置
- 共享对象初始化代码的地址
- 等等

所以他是一个**结构数组**：

```c++
/* Dynamic section entry.  */

typedef struct
{
  Elf32_Sword	d_tag;			/* Dynamic entry type */
  union
    {
      Elf32_Word d_val;			/* Integer value */
      Elf32_Addr d_ptr;			/* Address value */
    } d_un;
} Elf32_Dyn;
```

P205表7-2有一些常用的d_tag类型。就是可能的用的到的一些类型。比如动态链接符号表的地址等等。



### 7.5.3 动态符号表









