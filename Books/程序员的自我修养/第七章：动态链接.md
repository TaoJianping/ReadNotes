# 第七章：动态链接

- 7.1 为什么要动态链接
- 7.2 简单的动态链接例子
- 7.3 地址无关代码
- 7.4 延迟绑定（PLT）
- 7.5 动态链接相关结构
- 7.6 动态链接的步骤和实现
- 7.7 显式运行时链接



## 7.1 为什么要动态链接

- 浪费内存空间和磁盘空间
- 模块更新困难
- 可拓展性兼容性差

把链接这个过程推迟到运行时再进行，这就是**动态链接（Dynamic Linking）**的基本思想。

### 动态链接的基本实现

在Linux系统中，ELF动态链接文件被称为**动态共享对象（Dynamic Shared Objects）**，简称共享对象，他们一般是以“.so”为拓展名的一些文件；在Windows系统中，动态文件则是DLL。

当程序被装载的时候，系统的**动态链接器**会将程序所需的所有的动态链接库装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。



## 7.2 简单的动态链接例子

![image](https://tvax1.sinaimg.cn/large/005wgNfbgy1gaf2rumv9qj30k60g6wgt.jpg)

如果一个函数定义在某个动态共享对象中，那么链接器会将这个符号的引用标记为一个动态链接的符号，不对他进行地位重定位，把这个过程留到装载时进行。

### 动态链接器

动态链接器与普通共享对象一样被映射到进程的地址空间，在系统开始运行Program之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给Program，然后开始执行。

共享对象的最终装载地址在编译时是不确定的。



## 7.3 地址无关代码

### 7.3.1 固定装载地址的困扰

> 共享对象在被装载时，如何确定它在进程虚拟地址空间中的位置？

#### 静态共享库（Static Shared Library）

静态共享库的做法就是将程序的各个模块统一交给操作系统来管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。

##### 问题

- 地址冲突
- 升级困难

为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在任意地址加载？即：

- 共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。



### 7.3.2 装载时重定位

因为固定装载地址不大合适，所以我们可以：

- 在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序所有的绝对地址引用进行重定位。

这种就叫做**装载时重定位（Load Time Relocation）**，而我们在前面静态链接时提到过重定位，那时的重定位叫做**链接时重定位（Link Time Relocation）**。

但是他也有缺点：

- 没有办法做到同一份指令被多个进程共享，这样就失去了动态链接节省内存的一大优势



### 7.3.3 地址无关代码

因为装载时重定位和固定装载地址都有自己的问题，所以我们就引入了**地址无关代码（PIC，Position-independent Code）**。基本的原理：

> 把指令中那些需要修改的部分分离出来，跟数据部分放在一起，这样指令的部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。

分四种情况讨论：

- 第一种是模块内部的函数调用、跳转等；
- 第二种是模块内部的数据访问，比如模块内中定义的全局变量、静态变量；
- 第三种是模块外部的函数调用、跳转等；
- 第四种是模块外部的数据访问，比如其他模块中定义的全局变量；

```c
static int a;
extern int b;
extern void ext();

void bar()
{
    a = 1;		// Type 2
    b = 2;		// Type 4
}

void foo()
{
    bar();		// Type 1
    ext();		// Type 3
}
```













