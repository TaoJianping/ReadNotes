## 5.1 优化编译器的能力和局限性

有几个妨碍编译器优化的因素。

### 1. 内存别名使用（memory aliasing）

在只执行安全的优化中，编译器必须假设不同的指针可能指向内存中同一位置，这种两个指针可能指向同一个内存位置的情况称为**内存别名使用（memory aliasing）**。如果编译器不能确定两个指针是否指向同一个位置，就必须假设什么情况都有可能，这就限制了可能的优化策略。举个例子：

```c
x = 1000;
y = 3000;
*q = y;
*p = x;
t1 = *q; // 1000 or 3000?
```

如果p和q指向同一个内存地址，t1等于1000，否则就是3000.

### 2. 函数调用

```c
long counter = 0;
long f();


long func1() {
    return f() + f() + f() + f();
}

long func2() {
    return 4*f();
}

long f() {
    return counter++;
}
```

虽然func1和func2在某些情况下可能产生相同的结果，但是f()这个函数里面可能会涉及到全局程序状态的改变，所以函数有没有副作用很重要！

大多数编译器不会试图判断一个函数是否没有副作用，如果没有，就可能被优化成像func2中的样子。相反，编译器会假设最造的情况，并保持所有的函数调用不变。

#### 用内联函数替换优化函数调用。

包含函数调用的代码可以用一个称为内联函数替换（inline substitution，或者简称“内联（inlining）”）的过程进行优化，此时，将函数调用替换为函数体。

优点：

- 减少函数调用的开销
- 允许对展开的代码做进一步优化

缺点：

- GCC职场是在单文件中定义的函数的内联
- 断点可能无法追踪



## 5.2 表示程序性能

我们引入度量标准每元素的周期数（Cycles Per Element，CPE），作为一种表示程序性能并知道我们改进代码的方法。

