# 第七章：链接

## 7.1 编译器驱动程序

```shell
linux> gcc -Og -o prog main.c sum.c
```



![image](https://tva1.sinaimg.cn/large/005wgNfbgy1gam0yxw99vj30gr0d1gpy.jpg)

一个普通的编译过程

- 驱动程序首先运行C预处理器（cpp），它讲C的源程序`main.c`翻译成一个ASCII码的中间文件`main.i`：

  ```shell
  cpp [other arguments] main.c /tmp/main.i
  ```

- 接下来，驱动程序运行C编译器（ccl），它将`main.i`翻译成一个ASCII汇编语言文件`main.s`：

  ```shell
  ccl /tmp/main.i -Og [other arguments] -o /tmp/main.s
  ```

- 然后，驱动程序运行汇编器（as），他将main.s翻译成一个可重定位目标文件（relocatable object file）`main.o`：

  ```shell
  as [other arguments] -o /tmp/main.o /tmp/main.s
  ```

- 最后，它运行链接器程序ld，将`main.o`和`sum.o`以及一些必要的系统目标文件组合起来，创建一个**可执行目标文件（executable object file）**prog：

  ```shell
  ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
  ```

shell调用操作系统中一个叫做**加载器（loader）**的函数，他将可执行文件prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头。



## 7.2 静态链接

像Linux LD程序这样的**静态链接器（Static linker）**以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

- 符号解析（symbol resolution）
- 重定位（relocation）



## 7.3 目标文件

目标文件有三种形式：

- 可重定位目标文件
- 可执行目标文件
- 共享目标文件



## 7.4 可重定位目标文件

![image](https://tvax1.sinaimg.cn/large/005wgNfbgy1gam2387sawj30c70etgp8.jpg)

图7-3展示了一个典型的ELF可重定位目标文件。

书上还有简单的解释了各个段的作用。



## 7.5 符号和符号表

每个可重定位目标模块m都有一个符号表，它包含m定义和引用的符号的信息。在连接器的上下文中，有三种不同的符号：

- 有模块m定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量；
- 由其他模块定义并被模块m引用的全局符号。这些符号被称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量。
- 只被模块m定义和引用的局部符号。他们对应于带static属性的C函数和全局变量。这些符号在模块m中任何位置都可见，但是不能被其他模块引用。

> **COMMON和.bss的区别**
>
> COMMON	未初始化的全局变量
>
> .bss				未初始化的静态变量，以及初始化为0的全局或静态变量



## 7.6 符号解析

### 7.6.1 链接器如何解析多重定义的全局符号

链接器的输入是一组可重定位目标模块，如果多个模块定义同名的全局符号，按照以下规则：

- 规则1：不允许有多个同名的强符号；
- 规则2：如果有一个强符号和多个弱符号同名，选择强符号；
- 规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个（应该不是，是按照顺序来的好像。还有就是按照大小来？可以看程序员的自我修养那本书，讲的更好。）

>强符号：函数和已初始化的全局变量
>
>弱符号：未初始化的全局变量

#### COMMON段的实际用途

![image](https://tvax3.sinaimg.cn/large/005wgNfbly1gan4mgz1f8j30ol068ahs.jpg)



### 7.6.2 与静态库链接

![image](https://tvax3.sinaimg.cn/large/005wgNfbly1gan5u21zi5j30iz09gq6h.jpg)



### 7.6.3 链接器如何使用静态库来解析引用

在符号解析阶段，链接器从左到右按照他们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。

在这次扫描中，链接器维护了：

- 一个可重定位目标文件的集合E；
- 一个未解析的符号集合U；
- 以及一个在前面输入文件中已定义的符号集合D；

一开始的时候，三个集合都为空，接下来：

- 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。
  - 如果是一个目标文件，那么链接器会把f添加到E，并且修改U和D反应f中的符号定义和引用，并继续下一个输入文件。
  - 如果是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m添加到E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中的所有的成员目标文件都依次进行这个过程，知道U和D都不再发生变化。此时，不包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个文件。
- 如果当链接器完成对命令行输入文件地扫描之后，U是非空地，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中地目标文件，构建输出地可执行文件。



## 7.7 重定位

一旦链接器完成了符号解析这一步，就把代码中地每个符号引用和正好一个符号定义关联起来，词是，链接器就知道它的输入目标中的代码节和数据节的确切大小，现在开始就可以重定位了。在这个步骤中，将合并输入模块，并为每个符号分配运行地址。

重定位由两步组成：

- 重定位节和符号定义：在这一步，链接器将所有相同类型的节合并为同一类型的新的聚合节。然后链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。
- 重定位节中的符号引用：在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为**重定位条目（relocation entry）**的数据结构。



### 7.7.1 重定位条目

当生成一个目标文件的时候，目标文件时不知道自己会被加载到内存的具体地点的，所以它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。

所以他会生成一个节，里面是数组，专门存放这些需要重定位的信息（比如.rel.text）。下面是ELF重定位条目的格式：

```c
typedef struct
{
  Elf64_Addr	r_offset;		/* Address */
  Elf64_Xword	r_info;			/* Relocation type and symbol index */
  Elf64_Sxword	r_addend;		/* Addend */
} Elf64_Rela;
```

`r_info`其实是个64位的，前32位是`type`，后32位是`symbol`。

- type：告知链接器如何修改新的引用；
- symbol：标识被修改引用应该指向的符号；

ELF定义了32种不同的重定位类型，这里由两种：

- R_X86_64_PC32：重定位一个使用32位PC相对地址的引用；
- R_X86_64_32：重定位一个使用32位绝对地址的引用；



### 7.7.2 重定位符号引用

![image](https://tvax4.sinaimg.cn/large/005wgNfbly1gao2ck6l0pj30o80cnjzf.jpg)

具体的书上由详细的计算过程了，如果还有诱惑去看书。



## 7.8 可执行文件

![image](https://tva2.sinaimg.cn/large/005wgNfbly1gao80rhi7aj30j20cowkx.jpg)



## 7.9 加载可执行目标文件

![image](https://tva3.sinaimg.cn/large/005wgNfbly1gao87plj1jj30ly0h0wq6.jpg)



## 7.10 动态链接共享库

共享库是一个目标模块，在运行和加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程叫**动态链接**，是由一个**动态链接器（dynamic linker）**的程序来执行的。共享库也称为**共享目标（shared object）**，在Linux系统中通常用.so后缀来表示。

共享库是以两种不同的方式来共享的。

- 首先，在任何给定的文件系统中，对于一个库只有一个.so文件。所有引用这个库的可执行目标文件都共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用他们的可执行的文件中。
- 其次，在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。

![image](https://tvax4.sinaimg.cn/large/005wgNfbly1gao8x3i0hij30fq0fzwki.jpg)



## 7.11 从应用程序中加载和链接共享库

当程序运行之后，也可以加载共享库。下面就是提供的接口：

```c
#include <dlfcn.h>

void *dlopen(const char *filename, int flag);
void *dlsym(void *handle, char *symbol);
int dlclose(void *handle);
const char *dlerror(void);

```



## 7.12 位置无关代码

