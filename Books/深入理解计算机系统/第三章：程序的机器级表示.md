## 3.3 数据格式

intel的术语

- 字（word）：16位数据类型
- 双字（double words）：32位
- 四字（quad words）：64位



![image](https://ws2.sinaimg.cn/large/005wgNfbly1g73nsmfdttj30jw06gtcn.jpg)





## 3.4 访问信息

![image](https://wx3.sinaimg.cn/large/005wgNfbly1g73np8yflpj30ha0kldx0.jpg)



#### 3.4.1 操作数指示符

大多数指令有一个或者多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。

![image](https://wx4.sinaimg.cn/large/005wgNfbly1g73oehtgeoj30j0090dna.jpg)

- 立即数（immediate）
- 寄存器（register）
- 内存引用



#### 3.4.2 数据传送指令

MOV类由movb、movw、movl和movq等组成。

MOV (source) (destination)

![image](https://wx3.sinaimg.cn/large/005wgNfbly1g73pk1bchxj30cs05l0ux.jpg)

源操作数指定的值是一个（立即数 | 寄存器 | 内存中），目的操作数指定一个位置（寄存器 | 内存地址）

> x86平台的限制
>
> 在x86平台中，加一个限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令——第一条指令将原值加载到寄存器，第二条将该寄存器值写入目的位置



因为有小数据到大数据的传输的需求，所以有两类特殊的数据移动指令。

MOVZ类中的指令把目的中剩余的字节填充为0。

![image](https://ws3.sinaimg.cn/large/005wgNfbly1g73qdrpl1uj30gs05eadi.jpg)

MOVS类中的指令通过符号拓展来填充，把源操作的最高位进行复制。

![image](https://ws4.sinaimg.cn/large/005wgNfbly1g73qgb837lj30i9075td6.jpg)



#### 3.4.4 压入和弹出栈数据

其实就是push和pop啦，在x86-64中，程序栈存放在内存中的某个区域，栈是向下增长的，这样一来，栈顶元素的地址是所有栈中元素地址的最低位。栈指针%rsp保存着栈顶元素的地址。

![image](https://ws4.sinaimg.cn/large/005wgNfbly1g753no7q22j30di04ogno.jpg)

![1568896180254](C:\Users\taojianping\AppData\Roaming\Typora\typora-user-images\1568896180254.png)

![1568896254148](C:\Users\taojianping\AppData\Roaming\Typora\typora-user-images\1568896254148.png)

注意，qushq和popq转成机器码是只要一个字节。



## 3.5 算术和逻辑操作

![image](https://ws4.sinaimg.cn/large/005wgNfbly1g75rqqzmnrj30j40cb0z7.jpg)



#### 3.5.1 加载有效地址

加载有效地址（load effective address）指令leaq实际上是movq指令的变形。他的指令形式是从内存读数据到寄存器，但实际上他根本没有引用内存。

- 将有效地址写入到目的操作数
- 简介的描述算术操作



#### 3.5.2 一元和二元操作

###### 一元

只有一个操作数，既是源又是目的。

***instruction D (register | memory)***



###### 二元：D  = D - S

***instruction S(immediate | register | memory) D(register | memory)***



#### 3.5.3 移位操作

***instruction S(immediate | %cl) D(register | memory)***



#### 3.5.5 特殊的算术操作

![image](https://wx3.sinaimg.cn/large/005wgNfbly1g76ats13qdj30n409mahc.jpg)

Intel把16个字节的数称为八字（oct word）

是64位乘以64位得到128位的数字。用的是IMUL类。

一个是无符号数乘法（mulq），而另一个是补码乘法（imulq）。

这条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx(高64位)和%rax(低64位)中。

除法的大同小异，不写了。



## 3.6 控制

#### 3.6.1 条件码

除了寄存器CPU还维护着一组单个位的条件码（condition code）寄存器。

常见的有：

- CF：进位标志位
- ZF：零标志
- SF：符号标志，最近的操作得到了结果为负数
- OF：溢出标志。最近的操作导致一个补码溢出--正溢出或者负溢出

leaq指令不会该表任何条件码，因为他是用来进行地址计算的。

![image](https://ws4.sinaimg.cn/large/005wgNfbly1g76yi6y3l5j30dm0dh0x3.jpg)

CMP指令和TEST指令只会设置条件码而不会改变任何寄存器。



#### 3.6.2 访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

1. 可以根据条件码的某种组合，将一个字节设置为0或者1
2. 可以条件跳转到程序的某个其他部分
3. 可以有条件的传送数据

![image](https://wx1.sinaimg.cn/large/005wgNfbly1g76ysdfipej30ly0djqbg.jpg)

图 3-14 描述了条件码使用方法1的场景。



#### 3.6.3 跳转指令

跳转（jump）指令会导致执行切换到程序中一个全新的位置。在汇编中，这些跳转的目的地通常用一个标号（label）表示。

跳转分为：

- **直接跳转**：就是正常的跳转到label所在的地址

- **间接跳转**：写法是‘*’后面跟一个操作数指示符

  ![image](https://wx2.sinaimg.cn/large/005wgNfbly1g77344ebw7j30fx04wmz8.jpg)

完整的跳转表：

![image](https://wx3.sinaimg.cn/large/005wgNfbly1g7734ovvocj30lg0ekgwb.jpg)



#### 3.6.4 跳转指令的编码

跳转指令有几种不同的编码

- PC-relative：最常用的，他们会将目标指令的地址与紧跟在跳转指令后面的那条指令的地址之间的差作为编码。
- 绝对地址：用4个字节直接指定目标。

> rep和repz的作用，没什么用，可以无视，详细的解释可以看p141

