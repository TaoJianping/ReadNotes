# 拷贝、赋值与销毁

#### 学习目标

- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值运算符（move-assignment operator）

- 析构函数（destructor）



#### 拷贝构造函数

###### 定义

如果一个构造函数的第一个参数是自身类型的引用，且任何额外的参数都有默认值，则此构造函数是拷贝构造函数。

```c++
class Foo {
public:
    Foo();      // 默认构造函数
    Foo(const Foo &);       // 拷贝构造函数
};
```

###### 发生场景

- =号定义变量
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员

###### 为什么要用引用来当拷贝构造函数的参数

在作为参数或者返回的值的时候，他都会用调用拷贝构造函数，如果他没有用引用作为参数，那么他在调用拷贝构造函数的时候还会调用拷贝构造函数，会无限递归调用下去。（P442 参数和返回值）



#### 拷贝赋值运算符

```c++
Sales_data trans, accum;
trans = accum;		// 使用Sales_data的拷贝赋值运算符	
```

上面的就是拷贝赋值运算符的一个使用场景，所以可以看到他和拷贝构造的不同

```c++
MyStr str1(1, "test 1");
cout << "====================" << endl;
MyStr str2;
str2 = str1;        // operator =
cout << "====================" << endl;
MyStr str3 = str1;      // copy constructor
```

- 拷贝构造函数是重新构造一个对象的时候调用的。
- 而拷贝赋值函数是对一个已经申明的对象进行“=”号赋值的时候调用的。

操作对象是否存在是调用他俩的关键性差别



#### 析构函数

构造函数初始化对象的非static数据成员，还可能做一些其他工作；而析构函数释放对象使用的资源，并销毁对象的非static数据成员。

###### 什么时候会调用析构函数

- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向他的指针应用delete运算符时被销毁
- 对于临时对象，当创建他的完整表达式结束时被销毁



#### 移动构造函数

TODO



#### 移动赋值运算符

TODO



#### 使用=default

一、 类中的默认函数

1. 默认构造函数
2. 默认析构函数
3. 拷贝构造函数
4. 拷贝赋值函数
5. 移动构造函数
6. 移动拷贝函数

有时候当我们仅创建了有参构造函数后，如果你想调用无参构造函数编译是会报错的。因为一旦你自己定义了构造函数，系统的默认构造函数是被屏蔽的，也就是说此时是没有无参构造函数的，所以我们需要自己定义一个无参构造函数。但是现在在C++11中，如果我们仅定义了有参构造函数，可以通过default关键字让默认构造函数恢复。

```c++
class Foo {
    Foo(int i) {};
};

int main() {
    auto f = new Foo();     // error 默认无参构造函数
    return 0;
}
```

可以看到你是无法无参构建的，因为当你写了构造函数之后，原本默认生成的无参构造函数就不生成了，你必须显示的再写一个构造函数。

```c++
class Foo {
    Foo(int i) {};
    Foo() {};
};

int main() {
    auto f = new Foo();		// successful
    return 0;
}
```

这样你就可以了。但是你可能会觉得麻烦，就有关键字default了。

```c++
class Foo {
public:
    Foo(int i) {};;
    Foo() = default;
};

int main() {
    auto f = new Foo();
    return 0;
}
```

有了`= default`之后就可以显示的申明默认构造函数了。



#### 阻止拷贝

> 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式的还是显式的

我们可以通过`delete`关键字将拷贝构造函数和拷贝赋值定义为**删除的函数（deleted function）**

```c++
class NoCopy {
public:
    NoCopy() = default;     // 使用合成的默认构造函数
    NoCopy(const NoCopy&) = delete;     // 阻止拷贝构造
    NoCopy & operator=(const NoCopy&) = delete;     // 阻止拷贝赋值
    ~NoCopy() = default;        // 使用合成的析构函数
};
```

其实我们可以对任何的函数用这个delete关键字，真的很神奇。包括析构函数，但是这个除非你真的很明白你自己在干什么，不然你绝对不要delete析构函数。

一旦你删除了析构函数，

- 编译器将不允许定义该类型的变量或者创建该类型的临时对象。

- 而且，如果一个类有个成员的类型删除了析构函数，我们页不能定义该类的变量或者临时对象

因为如果一个成员的析构函数是删除的，则该成员无法被销毁，而如果一个成员无法被销毁，则对象的整体也就无法被销毁了。

```c++
class NoDtor {
public:
    NoDtor() = default;
    ~NoDtor() = delete;
};

int main() {
    NoDtor nd;      // 错误：NoDtor的析构函数是删除的
    NoDtor *p = new NoDtor();       // 正确
    delete p;       // 错误: 析构函数已经被删除了
    return 0;
}
```

对于析构函数已经删除的类型，不能定义该类型的变量或者释放指向该类型动态分配对象的执政。