## Index

- The Parsing Process
- Context-Free Grammars
- Parse Trees and Abstract Syntax Trees
- Ambiguity
- Extended Notations: EBNF and Syntax Diagrams
- Formal Properties of Context-Free Languages
- Syntax of the Tiny Language



Parsing is the task of determing the syntax, or structure, of a program. It is also called ***syntax analysis***



## 3.1 THE PARSING PROCESS

It is the task of the parser to determine the syntactic structure of a program from the tokens produced by the scanner and, either explicitly or implicity, to construct a parse tree or syntax tree that represents this structure.

本质上就是说：给定文法G和句子s，是否存在句子s的推导？



## 3.2 CONTEXT-FREE GRAMMARS

A context-free prammar is a specification for the syntatic structure of a programming language.



## 3.3 Parse Trees and Abstract Syntax Trees

#### 3.31 Parse Tree

A **parse tree** corresponding to a derivation is a labeled tree in which interior nodes are labeled by nonterminals, the leaf nodes are labeled by terminals, and the children of each internal node represent the replacement of the associated nonterminal in one step of the derivation.

parse tree 能够反映出语法的每一步的推导过程。但是和推导所用的顺序无关（最左，最右，其他）。 但是有一点很重要，这个树推出来后，他的推导顺序却会影响他的含义。因为他并不涉及precedence。



## 3.4 Ambiguity 

A grammar that generates a string with two distinct parse trees is called an **ambiguous grammar**.

#### Cause a serious problem

- it does not specify precisely the syntactic structure of program.
- 程序的结果也可能不是唯一的。



#### Two basic methods are used to deal with:

- disambiguating rule: state a rule that specifies in each ambiguous case which of the parse trees(or syntax tree) is the correct one.
- change the grammar into a form that forces the construction of the correct parse tree, thus remoing the ambiguity.(文法重写)



> left associative: 左结合，加法这些算数的时候要做到这个。



#### The Dangling Else Problem

TODO



## 3.6 FORMAL PROPERTIES OF CONTEXT-FREE LANGUAGE

#### Definition

- A set **T** of terminals
- A set **N** of nonterminals(disjoint from T)
- A set **P** of productions, or grammar rules, of the form $A \rightarrow \alpha$, where A is an element of N and $\alpha$ is an element of $(T \bigcup N)*$ (a possibly empty sequence of terminals and nonterminals)
- A start symbol **S** From the set N



**G**: a grammar as defined above, $G = (T, N, P, S)$

A **derivation step** over G is of the form $\alpha A \gamma \Rightarrow \alpha \beta \gamma $, where $\alpha$ and $\gamma$ are elements of $(T \bigcup N)*$ and $A \rightarrow \beta$ is in P.

The union $T \bigcup N$ of the sets of terminals and nonterminals is sometimes called   the **set of symbols** of G, and a string $\alpha$ in $(T \bigcup N)*$ is called a **sentential from**.

A **derivation** over the grammar G is of the form $S \Rightarrow* w$, where $w \in T^*$(i.e., w is a string of terminals only, called a **sentence**).

The **language generated by G**, written L(G), is defined as the set  $L(G) = \{w \in T^* | there exists a derivation S \Rightarrow^* w \  of \ G\}$. That is, L(G) is the set of sentences derivable from S.

A set of strings L is said to be a **context-free language** if there is context-free grammar G such that $L = L(G)$.



#### leftmost derivation

TODO



#### rightmost derivation

TODO



#### Parse tree

- Each node is labeled with a terminal or a nonterminal or $\varepsilon$
- The root node is labeled with the start symbol S
- Each leaf node is labeled with a terminal or with $\varepsilon$
- Each nonleaf node is labeled with a nonterminal
- If a node with label A $\in$ N has n children with labels $X_1, X_2, ..., X_n$ (which may be terminals or nonterminals), then $A \rightarrow X_1, X_2, ..., X_n \in P $ (a production of the grammar).



#### What is the difference between context-free and context-sensitive 

***context-free***: nonterminals appear by themselves to the left of the arrow in context-free rules. Thus, a rule says that A may be replaced by $\alpha$ anywhere, regardless of where A occurs.

***context-sensitive***: A **context-sensitive grammar** (**CSG**) is a [formal grammar](https://en.wikipedia.org/wiki/Formal_grammar) in which the left-hand sides and right-hand sides of any [production rules](https://en.wikipedia.org/wiki/Production_(computer_science)) may be surrounded by a context of [terminal](https://en.wikipedia.org/wiki/Terminal_symbol) and [nonterminal symbols](https://en.wikipedia.org/wiki/Nonterminal_symbol)



下面是知乎上的一个解释：

> 上下文无关文法就是说这个文法中**所有的产生式左边只有一个非终结符**，比如：
> S -> aSb
> S -> ab
> 这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。比如：
> aSb -> aaSbb
> S -> ab
> 这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。



#### Chomsky hierarchy

| Grammar | Languages                                                    | Automaton                                                    | Production rules (constraints)*                              | Examples[[3\]](https://en.wikipedia.org/wiki/Chomsky_hierarchy#cite_note-3) |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Type-0  | [Recursively enumerable](https://en.wikipedia.org/wiki/Recursively_enumerable_language) | [Turing machine](https://en.wikipedia.org/wiki/Turing_machine) | {\displaystyle \alpha A\beta \rightarrow \gamma }![{\displaystyle \alpha A\beta \rightarrow \gamma }](https://wikimedia.org/api/rest_v1/media/math/render/svg/f9039cfe0e71e691bcd1720a9bd8f599fa914b0d) | {\displaystyle L=\{w\|w}![{\displaystyle L=\{w\|w}](https://wikimedia.org/api/rest_v1/media/math/render/svg/46f75a36ee91fb70c39b78145c087df4abdb1035) describes a terminating Turing machine{\displaystyle \}}![\}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2cf208e5d370391e66767f13641bd5ee6ad93825) |
| Type-1  | [Context-sensitive](https://en.wikipedia.org/wiki/Context-sensitive_grammar) | [Linear-bounded non-deterministic Turing machine](https://en.wikipedia.org/wiki/Linear_bounded_automaton) | {\displaystyle \alpha A\beta \rightarrow \alpha \gamma \beta }![\alpha A \beta \rightarrow \alpha \gamma \beta](https://wikimedia.org/api/rest_v1/media/math/render/svg/1173552bcbf68bb06baf9b0a2f543dbc845caefd) | {\displaystyle L=\{a^{n}b^{n}c^{n}\|n>0\}}![{\displaystyle L=\{a^{n}b^{n}c^{n}\|n>0\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2bb63b71ffcba840f36e802aafe4c9951cf9ec38) |
| Type-2  | [Context-free](https://en.wikipedia.org/wiki/Context-free_grammar) | Non-deterministic [pushdown automaton](https://en.wikipedia.org/wiki/Pushdown_automaton) | {\displaystyle A\rightarrow \alpha }![{\displaystyle A\rightarrow \alpha }](https://wikimedia.org/api/rest_v1/media/math/render/svg/13dc432701b1477bc9ba32b0d71c58ecf2d44d9e) | {\displaystyle L=\{a^{n}b^{n}\|n>0\}}![{\displaystyle L=\{a^{n}b^{n}\|n>0\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/dfafe0fa14e5249f492f5cbde42062ba4904d56f) |
| Type-3  | [Regular](https://en.wikipedia.org/wiki/Regular_grammar)     | [Finite state automaton](https://en.wikipedia.org/wiki/Finite_state_automaton) | {\displaystyle A\rightarrow {\text{a}}}![{\displaystyle A\rightarrow {\text{a}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/c5a21ff7c854fa27daf7ab3882590f938e5720e9) and {\displaystyle A\rightarrow {\text{a}}B}![{\displaystyle A\rightarrow {\text{a}}B}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8a487d4dba9e9959ea3a34e06b5e5677c8eff4d4) | {\displaystyle L=\{a^{n}\|n\geq 0\}}![{\displaystyle L=\{a^{n}\|n\geq 0\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2d8085f37ec7d2aa499b0d27008c940279088d09) |

[参考链接](<https://en.wikipedia.org/wiki/Chomsky_hierarchy#Type-0_grammars>)

