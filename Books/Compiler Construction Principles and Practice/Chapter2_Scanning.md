## Index

- 2.1 The Scanning Process
- 2.2 Regular Expressions
- 2.3 Finite Automata
- 2.4 From Regular Expression to DFAs
- 2.5 Implementation of a TINY Scanner
- 2.6 Use of Lex to Generate a Scanner Automatically

The scaning, or **lexical analysis**, phase of a compiler has the task of reading the source program as a file of characters and dividing it up into Tokens.

**Tokens**: each token is a sequence of characters that represents a unit of information in the source program. Typical examples:

- keywords
- identifiers
- special symbols



## 2.1 The Scanning Process

It is the job of the scanner to read characters from the source code and form them into logical units to be dealt with by further parts of the compiler (usually the parser).

Tokens fall into several **categories**:

- reserved words（保留关键字）
- special symbols（符号）
- multiple strings（数据类型？）

```c
typedef enum {
    IF, THEN, ELSE, PLUS, MINUS, NUM, ...
}
```



The string of characters represented by a token is sometimes called its **string value** or its **lexeme**.

Any value associated to a token is called an attribute of the token, and the **string value** is an example of an attribute.

Since the scanner will have to compute possibly several attributes for each token, it is often helpful to collect all the attributes into a single structured data type, which we could call a **token record**

```c
typedef struct {
    TokenType tokenval;
   	char * stringval;
    int numval;
} TokenRecord;

// as a union
typedef struct {
    TokenType tokenval;
    union {
        char * stringval;
    	int numval;
    } attribute;
} TokenRecord;
```



## 2.2 REGULAR EXPRESSIONS

Regular expressions represent patterns of strings of characters.

**L(r)**: language generated by the regular expression

**symbols**: 

**alphabet**: 

**metacharacters (metasymbols)**: 



#### 2.2.1 Definition of Regular Expressions

##### Basic Regular Expressions

These are just the single characters from the alphabet, which match themselves.
$$
L(a) = \{ a \}
$$


##### **empty string** & **empty set**

empty string is the string that contains no characters at all.

$$
L(\varepsilon) = \{\varepsilon\}
$$
empty set match no string at all
$$
L(\phi) = \{\}
$$
Note the difference between $\{\}$ and $\{\varepsilon\}$: the set $\{\}$ contains not strings at all, while the set $\{\varepsilon\}$ contains the single string consisting of no characters.



##### Regular Expression Operation

###### ***Choice Among Alternatives***

if ***r*** and ***s*** are regular expressions, then r|s is a regular expression which matches any string that is matched either by r or by s.
$$
L(r|s) = L(r)  \bigcup  L(s)
$$

###### ***Concatenation***

The concatenation of two regular expressions ***r*** and ***s*** is written as ***rs***, and it matches any string that is the concatenation of two string, the first of which matches ***r*** and the second of which matches ***s***.
$$
L((a|b)c) = L(a|b)L(c) = \{a, b\}\{c\} = \{ac, bc\}
$$

###### ***Repetition***

The repetition operation of a regular expression, sometimes also called (Kleene) closure, is written ***r****, where ***r*** is a regular expression. The regular expression ***r**** matches any finite concatenation of strings, each of which matches ***r***.
$$
L(r^*) = L(r)^*
$$

###### ***Precedence of Operations and Use of Parentheses***

***** is given the highest precedence, next **concatenation**, and **|** is given the lowest.

When we wish to indicate a different precedence, we must use parentheses to do so.

###### ***Names for Regular Expressions***

It is helpful as notational simplification to give a name to a long regular expression.
$$
digit = 0 | 1|2|3|...|9
$$
a **regular definition** of the name digit.

​                                                                                                                                                                                                                                                                                                

#### 2.2.2 Extensions to Regular Expressions

Some more regular extensions.

###### *ONE OR MORE REPETITIONS*

**r***: This allow r to be repeated 0 or more times.

**r+**: indicates one or more repetitions of ***r***.



###### *ANY CHARACTER*

A common situation is the need to match any character in the alphabet.

.\*b.\*



###### *A RANGE OF CHARACTERS*

We need to write a range of characters.

[A-Za-z]



###### *ANY CHARACTER NOT IN A GIVEN SET*

It is often helpful to be able to exclude a single character from the set of characters to be matched.

~(a|b|c)

in lex

[^abc]



###### *OPTIONAL SUBEXPRESSIONS*

We introduce the question mark metacharacter **r?** to indicate that string matched  by r are optional.

natural = [0-9]+

signedNatural = (+|-)? natural



#### 2.2.3 Regular Expressions for Programming Language Tokens

- *Numbers*

  ```
  nat = [0-9]+
  signedNat = (+|-)? nat
  number = signedNat("." nat)?(E signedNat)?
  ```

- *Reserved Words and Identifiers*

  An identifier must begin with a letter and contain only letters and digits

  ```
  reserved = if | while | do | ...
  
  letter = [a-zA-Z]
  digit = [0-9]
  identifier = letter(letter|digit)*
  ```

- *Comments*

- *Ambiguity, White Space, and Lookahead*

  1. Firstly, when a string can be either an identifier or a keyword, keyword interpretation is generally preferred.
  2. Second, when a string can be a single token or a sequence of several tokens, the single-token interpretation is typically preferred.

  ***token delimiters***: token分隔符，类似与whitespace, tab....

  ***free format***: 就是把这个token delimiters忽略掉，比如whitespace。



## 2.3 FINITE AUTOMATA

Finite automata, or finite-state machines, are a mathematical way of describing particular kinds of algorithms(or "machines"). In particular, finite automata can be used to describe the process of recognizing patterns in input strings, and so can be used to construct scanners.

![image](https://tvax3.sinaimg.cn/large/005wgNfbgy1g7jr2kz31mj30h50admxq.jpg)

- **states**: states are locations in the process of recognition that record how much of the pattern has already seen.
- **transitions**: record a change of from one state to another upon a match of the character or characters by which they are labeled.
- **start state**: The recognition process begins.
- **accepting states**: represent the end of the recognition process.

> what is the difference between **deterministic finite automata** and **nondeterministic finite automaton**?



#### 2.3.1 Definition of Deterministic Finite Automata

**Deterministic finite automata**: automa where the next state is uniquely given by the current state and the current input character.

A **DFA** M consisits of:

- an alphabet $\sum$
- a set of states S
- a transition function T: $S * \sum -> S$
- a start state $s_0 \in S$
- a set of accepting states $A \subset S$

The language accepted by M, written L(M), is defined to be the set of strings of characters $c_0c_1.....c_n$ with each $c_i \in \sum$ such that there exsits states $s_1 = T(s_0, c_1), s_2 = T(s_1, c2)...s_n = T(s_{n-1}, c_n)$ with an element of A(i.e., an accepting state).

![image](https://tva4.sinaimg.cn/large/005wgNfbgy1g7kvbzyi22j30hd0cemxx.jpg)

- a new state **error**
- the error transition **other**: other represents any character not appearing in any other transition from the state where it originates.
- all transitions from the error state go back to itself, we have labeled these transitions **any** to indicate that any characterresults in this transition.



#### 2.3.2 Lookahead, Backtracking, and Nondeterministic Automata

An NFA(nondeterministic finite antomaton) M consists:

- an alphabet $\sum$ 
- a set of states S
- a transition function T: $S * (\sum \bigcup \{\varepsilon\}) -> \vartheta$
- a start state $s_0$ from S
- a set of accepting states A from S

The sequence of transitions that accepts a paticular string is not determined at each step by the state and next input character.



## 2.4 FROM REGULAR EXPRESSIONS TO DFAs

### 2.4.1 From a Regular Expression to an NFA

The construction we will describe is known as **Thompson's construction**.



#### Basic Regular Expressions

A basic regular Expressions is of the form a, $\epsilon$ or $\phi$ 

- a: a represents a match of a single character from the alphabet
- $\epsilon$: represents a match of the empty string
- $\phi$: represents a match of no strings at all

![image](https://tva4.sinaimg.cn/large/005wgNfbly1g9v4sqtnu8j30c40343yg.jpg)

![image](https://tvax4.sinaimg.cn/large/005wgNfbly1g9v4t2xu99j30cv03wt8p.jpg)



#### Concatenation

![image](https://tva4.sinaimg.cn/large/005wgNfbly1g9v505f0egj30au05e3yo.jpg)



#### Choice Among Alternatives

![image](https://tvax4.sinaimg.cn/large/005wgNfbly1g9v50zm2moj30ae05ut93.jpg)



#### Repetition

![image](https://tva2.sinaimg.cn/large/005wgNfbly1g9v565i24jj30a9065jrn.jpg)



### 2.4.2 From an NFA to a DFA

subset construction

- eliminating $\epsilon$-transition
  - construction of $\epsilon$-closure
- eliminate multiple transitions from a state on a single input character



#### The Subset Construction

- We first compute the $\epsilon-closure$ of the start state of M;
- For this set, and for each subsequent set, we compute transitions on characters a as follows;
- Given a set $S$ of states and a character $a$ in the alphabet, compute the set $S'_a = \{t | for\ some\ s\ in\ S\ there\ is\ a\ transition\ from\ s\ to\ t\ on\ a \}$ ;
- Compute $\overline{S'_a}$ the $\epsilon-closure$ of $S'_a$. This defines a new state in the subset construction, together with a new transition $S\stackrel{a}{\longrightarrow}\overline{S'_a}$ ;
- Continue with this process until no new states or transitions are created;
- Mark as accepting those states constructed in this manner that contain an accepting state of M;