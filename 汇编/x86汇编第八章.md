## 程序结构和硬盘和显卡的访问控制

#### 程序结构

![image](https://ws4.sinaimg.cn/large/005wgNfbgy1g0xw7m1jodj30ki09dgm7.jpg)

- 头部程序：他们之间必须有一个协议，或者说协定，比如说，在用户程序内部的某个固定位置，包含一些基本的结构信息，每个用户程序都必须把自己的情况放在这里，而加载器也固定在这个位置读取。经验表明，把这个约定的地点放在用户程序的开头，对双方，特别是对加载器来说比较方便，这就是用户程序头部。
  - 用户程序的尺寸，即以字节为单位的大小。这对加载器来说是很重要的，加载器需要根据这一信息来决定读取多少个逻辑扇区（在本书中，所有程序在硬盘上所占用的逻辑扇区都是连续的）。
  - 应用程序的入口点，包括段地址和偏移地址。加载器并不清楚用户程序的分段情况，更不知道第一条要执行的指令在用户程序中的位置。因此，必须在头部给出第一条指令的段地址和偏移地址，这就是所谓的应用程序入口点（Entry Point）。
  - 段重定位表。用户程序可能包含不止一个段，比较大的程序可能会包含多个代码段和多个
    数据段。这些段如何使用，是用户程序自己的事，但前提是程序加载到内存后，每个段的地址必须
    重新确定一下。







#### 加载器工作流程

1. 初始化和决定加载位置
2. 准备加载用户程序

![image](https://ws1.sinaimg.cn/large/005wgNfbgy1g0xxuu0602j30al0ftt9d.jpg)



#### 从硬盘上读逻辑扇区的过程

在读硬盘的时候，我们是按照逻辑扇区的方式读取数据的，而不是分别发送磁头号，柱面号和扇区号。

逻辑扇区的编址方式最早是LBA28，使用 28 个比特来表示逻辑扇区号。

> 个人计算机上的主硬盘控制器被分配了 8 位端口，端口号从 0x1f0 到 0x1f7。

1. 设置要读取的扇区数量。这个数值要写入 0x1f2 端口

2. 设置起始 LBA 扇区号。28 位的扇区号太长，需要将其分成 4 段，分别写入端口 0x1f3、0x1f4、0x1f5 和 0x1f6 号端口。其中，0x1f3 号端口存放的是 0～7 位；0x1f4 号端口存放的是 8～15 位；0x1f5 号端口存放的是 16～23 位，最后 4 位在 0x1f6 号端口

    - 0x1f6 端口的低 4 位用于存放逻辑扇区号的 24～27位，第 4 位用于指示硬盘号，0 表示主盘，1 表示从盘。高 3 位是“111”，表示 LBA 模式。

        ![image](https://ws3.sinaimg.cn/large/005wgNfbgy1g0uhnkad27j30h708gglx.jpg)

3. 向端口0x1f7写入0x20，请求硬盘读。

4. 等待读写操作完成。端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送
    读写命令之后，硬盘就忙乎开了。如图 8-12 所示，在它内部操作期间，它将 0x1f7 端口的第 7 位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第 3位置“1”，意思是准备好了，请求主机发送或者接收数据

    ![image](https://wx2.sinaimg.cn/large/005wgNfbgy1g0uhqwyb95j30hv08tq3l.jpg)

    ```assembly
    .waits:
        in al,dx
        and al,0x88
        cmp al,0x08
        jnz .waits   
    ```

    

5. 连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。下面的代码假定是从硬盘读一个扇区（512 字节，或者 256 字节），读取的数据存放到由段寄存器 DS 指定的数据段，偏移地址由寄存器 BX 指定：

     ```assembly
         mov cx,256 		;总共要读取的字数
         mov dx,0x1f0		;因为0x1f0是硬盘的读端口，
     .readw:
          in ax,dx			;把dx寄存器的内容读到ax
          mov [bx],ax		;再把[ax]写到 DS:BX
          add bx,2			;改变偏移地址方便下次写入
          loop .readw		;循环
     ```

​    

#### 
