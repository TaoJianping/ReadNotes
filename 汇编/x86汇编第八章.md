## 程序结构和硬盘和显卡的访问控制

#### 程序结构

![image](https://ws4.sinaimg.cn/large/005wgNfbgy1g0xw7m1jodj30ki09dgm7.jpg)



#### 加载器工作流程

1. 初始化和决定加载位置
2. 准备加载用户程序

![image](https://ws1.sinaimg.cn/large/005wgNfbgy1g0xxuu0602j30al0ftt9d.jpg)



#### 从硬盘上读逻辑扇区的过程

在读硬盘的时候，我们是按照逻辑扇区的方式读取数据的，而不是分别发送磁头号，柱面号和扇区号。

逻辑扇区的编址方式最早是LBA28，使用 28 个比特来表示逻辑扇区号。

> 个人计算机上的主硬盘控制器被分配了 8 位端口，端口号从 0x1f0 到 0x1f7。

1. 设置要读取的扇区数量。这个数值要写入 0x1f2 端口

2. 设置起始 LBA 扇区号。28 位的扇区号太长，需要将其分成 4 段，分别写入端口 0x1f3、0x1f4、0x1f5 和 0x1f6 号端口。其中，0x1f3 号端口存放的是 0～7 位；0x1f4 号端口存放的是 8～15 位；0x1f5 号端口存放的是 16～23 位，最后 4 位在 0x1f6 号端口

    - 0x1f6 端口的低 4 位用于存放逻辑扇区号的 24～27位，第 4 位用于指示硬盘号，0 表示主盘，1 表示从盘。高 3 位是“111”，表示 LBA 模式。

        ![image](https://ws3.sinaimg.cn/large/005wgNfbgy1g0uhnkad27j30h708gglx.jpg)

3. 向端口0x1f7写入0x20，请求硬盘读。

4. 等待读写操作完成。端口 0x1f7 既是命令端口，又是状态端口。在通过这个端口发送
    读写命令之后，硬盘就忙乎开了。如图 8-12 所示，在它内部操作期间，它将 0x1f7 端口的第 7 位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第 3位置“1”，意思是准备好了，请求主机发送或者接收数据

    ![image](https://wx2.sinaimg.cn/large/005wgNfbgy1g0uhqwyb95j30hv08tq3l.jpg)

    ```assembly
    .waits:
        in al,dx
        and al,0x88
        cmp al,0x08
        jnz .waits   
    ```

    

5. 连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个 16 位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。下面的代码假定是从硬盘读一个扇区（512 字节，或者 256 字节），读取的数据存放到由段寄存器 DS 指定的数据段，偏移地址由寄存器 BX 指定：

     ```assembly
         mov cx,256 		;总共要读取的字数
         mov dx,0x1f0		;因为0x1f0是硬盘的读端口，
     .readw:
          in ax,dx			;把dx寄存器的内容读到ax
          mov [bx],ax		;再把[ax]写到 DS:BX
          add bx,2			;改变偏移地址方便下次写入
          loop .readw		;循环
     ```

     