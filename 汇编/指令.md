#### div

1. 16 位的二进制数除以 8 位的二进制数。

    在这种情况下，被除数必须在寄存器 AX 中，必须事先传送到 AX 寄存器里。除数可以由 8 位的通用寄存器或者内存单元提供。指令执 行后，商在寄存器 AL 中，余数在寄存器 AH 中。比如：

    ```assembly
    ;被除数	=> AX
    ;商		 => AL
    ;余数		=> AH
    div cl		; AX / CL
    ```

2. 32位的二进制数除以16位的二进制数

   在这种情况下，因为 16 位的处理器无法直 接提供 32 位的被除数，故要求被除数的高 16 位在 DX 中，低 16 位在 AX 中，指令执行后，商在 AX 中，余数在 DX 中。

   ```assembly
   ;被除数	=> DX:AX
   ;商		 => AX
   ;余数		=> DX
   div cx
   ```



#### movsb和movsw 

movsb 和 movsw 指令执行时，

原始数据串的段地址由 DS 指定，偏移地址由 SI 指定，简写为 DS:SI；

要传送到的目的地址由 ES:DI 指定；

传送的字节数（movsb）或者字数（movsw）由 CX 指 定。

除此之外，还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的 低地址端到高地址端；反向传送则正好相反。正向传送时，每传送一个字节（movsb）或者一个字 （movsw）， SI 和 DI 加 1 或者加 2；反向传送时，每传送一个字节（movsb）或者一个字（movsw） 时，SI 和 DI 减去 1 或者减去 2。不管是正向传送还是反向传送，也不管每次传送的是字节还是字， 每传送一次，CX 的内容自动减一。

单纯的 movsw 只能执行一次，如果希望处理器自 动地反复执行，需要加上指令前缀 rep（repeat），意思是 CX 不为零则重复。



#### cld

方向标志清零指令 cld，第 10 位是方向 标志 DF（Direction Flag），通过将这一位清零或者置 1，就能控制 movsb 和 movsw 的传送方向。 



####  rep

如果希望处理器自 动地反复执行，需要加上指令前缀 rep（repeat），意思是 CX 不为零则重复。



#### neg

它的功能很简单，用 0 减去指令中指定的操作数。neg 指令带有一个操作数，可以是 8 位或者 16 位的寄存器，或者内存单元。

例子：如果 AL 中的内容是 00001000（十进 制数 8），执行 neg al 后，AL 中的内容变为 11111000（十进制数－8）；

```assembly
neg al 
neg dx 
neg word [label_a
```



#### cbw（Convert Byte to Word）和 cwd（Convert Word to Double-word）

cbw 没有操作数，操作码为 98。它的功能是，将寄存器 AL 中的有符号数扩展到整个 AX。举 个例子，如果 AL 中的内容为 01001111，那么执行该指令后，AX 中的内容为 0000000001001111； 如果 AL 中的内容为 10001101，执行该指令后，AX 中的内容为 1111111110001101。 cwd 也没有操作数，操作码为 99。它的功能是，将寄存器 AX 中的有符号数扩展到 DX:AX。 举个例子，如果 AX 中的内容为 0100111101111001，那么执行该指令后，DX 中的内容为 0000000000000000，AX 中的内容不变；如果 AX 中的内容为 1000110110001011，那么执行该指令后，DX 中的内容为 1111111111111111，AX 中的内容同样不变。 



#### idiv

 idiv 的指 令格式和 div 相同，除了它是专门用于计算有符号数的。如果你决定要进行有符号数的计算，必须 采用如下代码：

```assembly
mov ax,0x0400 
mov bl,0xf0 
idiv bl                ;执行后，AL 中的内容为 0xc0，即十进制数－64
```



####  NASM编译器的$和$标记 

NASM 编译器提供了一个标记“$”，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的 标号。因此，jmp near $的意思是，转移到当前指令继续执行。； 

$是当前行的汇编地址；

$$是NASM 编译器提供的另一个标记，代表当前汇编节（段）的起始汇编地址。

当前程序没有定义节或 段，就默认地自成一个汇编段，而且起始的汇编地址是 0（程序起始处）