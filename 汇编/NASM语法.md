#### div

1. 16 位的二进制数除以 8 位的二进制数。

    在这种情况下，被除数必须在寄存器 AX 中，必须事先传送到 AX 寄存器里。除数可以由 8 位的通用寄存器或者内存单元提供。指令执 行后，商在寄存器 AL 中，余数在寄存器 AH 中。比如：

    ```assembly
    ;被除数	=> AX
    ;商		 => AL
    ;余数		=> AH
    div cl		; AX / CL
    ```

2. 32位的二进制数除以16位的二进制数

   在这种情况下，因为 16 位的处理器无法直 接提供 32 位的被除数，故要求被除数的高 16 位在 DX 中，低 16 位在 AX 中，指令执行后，商在 AX 中，余数在 DX 中。

   ```assembly
   ;(DX:AX) / (CX)
   ;被除数	=> DX:AX
   ;除数		=> CX
   ;商		 => AX
   ;余数		=> DX
   div cx
   ```



#### movsb和movsw 

movsb 和 movsw 指令执行时，

原始数据串的段地址由 DS 指定，偏移地址由 SI 指定，简写为 DS:SI；

要传送到的目的地址由 ES:DI 指定；

传送的字节数（movsb）或者字数（movsw）由 CX 指 定。

除此之外，还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的 低地址端到高地址端；反向传送则正好相反。正向传送时，每传送一个字节（movsb）或者一个字 （movsw）， SI 和 DI 加 1 或者加 2；反向传送时，每传送一个字节（movsb）或者一个字（movsw） 时，SI 和 DI 减去 1 或者减去 2。不管是正向传送还是反向传送，也不管每次传送的是字节还是字， 每传送一次，CX 的内容自动减一。

单纯的 movsw 只能执行一次，如果希望处理器自 动地反复执行，需要加上指令前缀 rep（repeat），意思是 CX 不为零则重复。



#### cld

方向标志清零指令 cld，第 10 位是方向 标志 DF（Direction Flag），通过将这一位清零或者置 1，就能控制 movsb 和 movsw 的传送方向。 



####  rep

如果希望处理器自 动地反复执行，需要加上指令前缀 rep（repeat），意思是 CX 不为零则重复。



#### neg

它的功能很简单，用 0 减去指令中指定的操作数。neg 指令带有一个操作数，可以是 8 位或者 16 位的寄存器，或者内存单元。

例子：如果 AL 中的内容是 00001000（十进 制数 8），执行 neg al 后，AL 中的内容变为 11111000（十进制数－8）；

```assembly
neg al 
neg dx 
neg word [label_a
```



#### cbw（Convert Byte to Word）和 cwd（Convert Word to Double-word）

cbw 没有操作数，操作码为 98。它的功能是，将寄存器 AL 中的有符号数扩展到整个 AX。举 个例子，如果 AL 中的内容为 01001111，那么执行该指令后，AX 中的内容为 0000000001001111； 如果 AL 中的内容为 10001101，执行该指令后，AX 中的内容为 1111111110001101。 cwd 也没有操作数，操作码为 99。它的功能是，将寄存器 AX 中的有符号数扩展到 DX:AX。 举个例子，如果 AX 中的内容为 0100111101111001，那么执行该指令后，DX 中的内容为 0000000000000000，AX 中的内容不变；如果 AX 中的内容为 1000110110001011，那么执行该指令后，DX 中的内容为 1111111111111111，AX 中的内容同样不变。 



#### idiv

 idiv 的指 令格式和 div 相同，除了它是专门用于计算有符号数的。如果你决定要进行有符号数的计算，必须 采用如下代码：

```assembly
mov ax,0x0400 
mov bl,0xf0 
idiv bl                ;执行后，AL 中的内容为 0xc0，即十进制数－64
```



####  NASM编译器的$和$标记 

NASM 编译器提供了一个标记“$”，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的 标号。因此，jmp near $的意思是，转移到当前指令继续执行。； 

$是当前行的汇编地址；

$$是NASM 编译器提供的另一个标记，代表当前汇编节（段）的起始汇编地址。

当前程序没有定义节或 段，就默认地自成一个汇编段，而且起始的汇编地址是 0（程序起始处）



#### 设置常数：equ

和其他伪指令 db、dw、dd 不同，用 equ 声明的数值不占用任何汇编地址，也不在运行时占用任何内存位置。它仅仅代表一个数值，应该是编译的时候自动转换成数字，和宏差不多。

```assembly
CONST equ 100		;
```



#### IN

从端口读数据，

in 指令的目的操作数必须是寄存器 AL 或者 AX，当访问 8 位的端口时，使用寄存器AL；访问 16 位的端口时，使用 AX。

in 指令的源操作数应当是寄存器 DX

```assembly
in al,dx		;in 写入的寄存器,要读的端口号
```

也许是为了方便，in 指令还有两字节的形式。此时，前一字节是操作码 0xE4 或者 0xE5，分别用于指示 8 位或者 16 位端口访问；后一字节是立即数，指示端口号。

```assembly
in al,0xf0		;这个就等于机器指令 E4 F0
```



#### OUT

和in正好相反，out是通过端口向外围设备发送数据

```assembly
;out 要写的端口号;写入的数据
out 0x37,al 	;写 0x37 号端口（这是一个 8 位端口）
out 0xf5,ax 	;写 0xf5 号端口（这是一个 16 位端口）
out dx,al 		;这是一个 8 位端口，端口号在寄存器 DX 中
out dx,ax 		;这是一个 16 位端口，端口号在寄存器 DX 中
```



#### ret和retf

ret 是近返回指令，当它执行时，处理器只做一件事，那就是从堆栈中弹出一个字到指令指针寄存器 IP 中。

retf 是远返回指令（return far），它的工作稍微复杂一点点。当它执行时，处理器分别从堆栈中弹出两个字到指令指针寄存器 IP 和代码段寄存器 CS 中。



#### call

call指令你可以把他理解为调用函数，为了调用函数，需要把IP和Ax等寄存器压栈。方便后续返回的时候回到原来调用的地方和原来各种各样寄存器的状态。下面是详细的调用过程，结合图可以看的更清楚。

![image](https://ws1.sinaimg.cn/large/005wgNfbgy1g15rwvdeqtj30cf0dsjsk.jpg)

如图 8-14 所示，在 call read_hard_disk_0 执行前，堆栈指针位于箭头①所指示的位置；call 指令执行后，由于压入了 IP 的内容，故堆栈指针移动到箭头②所指示的位置处；进入过程后，出于保护现场的目的，压入了 4 个通用寄存器 AX、BX、CX、DX，此时，堆栈指针继续向低地址方向推进到箭头③所指示的位置。
在过程的最后，是恢复现场，连续反序弹出 4 个通用寄存器的内容。此时，堆栈指针又回到刚进入过程内部时的位置，即箭头②处。最后，ret 指令执行时，由于处理器自动弹出一个字到 IP，故，过程返回后的瞬间，堆栈指针仍旧回到过程调用前，即箭头①所指示的位置。